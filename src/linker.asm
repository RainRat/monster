;*******************************************************************************
; LINKER.ASM
; The linker links the object code generated by the assembler into a binary
; (.prg or plain) or debug (.d) file.
;
; See the OBJECT CODE overview below for details on the object format.
;*******************************************************************************
.include "errors.inc"
.include "file.inc"
.include "labels.inc"
.include "line.inc"
.include "macros.inc"
.include "memory.inc"
.include "string.inc"
.include "strings.inc"
.include "util.inc"
.include "zeropage.inc"

.include "ram.inc"

.import __LINKER_BSS_LOAD__
.import __LINKER_BSS_SIZE__

;*******************************************************************************
; CONSTANTS
MAX_SECTIONS         = 8	; max number of memory sections
MAX_SEGMENTS         = 8	; max number of segments across all objects
MAX_OBJS             = 16	; max number of object files that may be used
MAX_SECTION_NAME_LEN = 8	; max length of a single section name
MAX_SEGMENT_NAME_LEN = 8	; max length of a single segment name

MAX_SYMBOL_NAME_LEN = 32
MAX_SYMBOLS         = 128	; max # of symbols per object file

SYM_IMPORT_BYTE     = 1
SYM_IMPORT_WORD     = 2
SYM_REL_EXPORT_BYTE = 3
SYM_REL_EXPORT_WORD = 4
SYM_ABS_EXPORT_BYTE = 5
SYM_ABS_EXPORT_WORD = 6

;*******************************************************************************
; SECTION flags
SECTION_FILL = $01	; flag to pad section's unused bytes with 0

;*******************************************************************************
; SEGMENT flags
SEGMENT_RO     = $01	; RO (readonly) writes to segment will be error
SEGMENT_DEFINE = $02

;*******************************************************************************
; INSTRUCTION OPCODES
I_SET_SEG   = 1
I_EMIT_BYTE = 2

;*******************************************************************************
; ZEROPAGE variables
; OBJPTR is the cursor in the object code (where we are reading in the current
; object file)
; SEGPTR is the cursor to the .PRG or .D file (where we are WRITIING)
objptr=zp::link
segptr=zp::link+2

;*******************************************************************************
; OBJFILES
; The list of object files to link
; Represented as a 0-terminated list of 0-terminated filename
; e.g.
;   "FILE1.O",0,"FILE2.O",0,0
.export __link_objfiles
__link_objfiles=mem::spare

;*******************************************************************************
.segment "LINKER_BSS"

numobjects:  .byte 0
numsegments: .byte 0
numsections: .byte 0
numfiles:    .byte 0

activeobj: .byte 0	; the current OBJECT (id) being linked
activeseg: .byte 0	; the current SEGMENT (id) being written

;*******************************************************************************
; OBJECT STATE
; These variables are used in the context of a single object file
numsymbols:  .byte 0

;*******************************************************************************
; SYMBOL NAMES
; This table contains the name for each symbol used in the object file
symbol_names:
.ifdef vic20
	.res MAX_SYMBOLS*MAX_SYMBOL_NAME_LEN
.else
.endif

;*******************************************************************************
; SYMBOL INFO
; This table contains corresponding flags for each symbol.
; It defines the type of symbol in the object file.
;  - ABS RELATIVE: an exported symbol with an relative (from SEGMENT) value
;    e.g. ```
;         .export LABEL`
;         LABEL:
;         ````
;  - ABS EXPORT: an exported symbol with an absolute value
;    e.g. ```
;         .export LABEL`
;         LABEL=$100
;         ````
;  - IMPORT: a symbol that is used in the object file but defined in another
;    e.g. ```
;         .IMPORT LABEL
;         jsr LABEL
;         ```
symbol_info:
.ifdef vic20
	.res MAX_SYMBOLS
.else
.endif

;*******************************************************************************
; SYMBOL SEGMENT IDS
; This table contains the index of each SYMBOL to its SEGMENT in the SEGMENTS
; table.
symbol_segment_ids:
.ifdef vic20
	.res MAX_SYMBOLS
.else
.endif

;*******************************************************************************
; SYMBOL OFFSETS
; This table contains the relative offsets for each symbol from their
; designated SEGMENTs (identified in the SEGMENT IDs table).
symbol_offsetslo:
.ifdef vic20
	.res MAX_SYMBOLS
.else
.endif

symbol_offsetshi:
.ifdef vic20
	.res MAX_SYMBOLS
.else

.endif

;*******************************************************************************
; SECTIONS
; The memory section contains up to MAX_SECTIONS of memory blocks.  Each
; defines the start and end addresses of the section plus a byte of flag
; data, which is used to, for example, flag that the section should be padded
; if the SEGMENTs that map to this section do not span the entire
; [start, stop] address space.
; The format of a SECTION is:
;  .word start addr
;  .word stop addr
;  .byte flags
sections_startlo: .res MAX_SECTIONS
sections_starthi: .res MAX_SECTIONS
sections_stoplo:  .res MAX_SECTIONS
sections_stophi:  .res MAX_SECTIONS
sections_flags:   .res MAX_SECTIONS
section_names:    .res MAX_SECTIONS*MAX_SECTION_NAME_LEN

.export sections_startlo
.export sections_starthi
.export sections_stoplo
.export sections_stophi
.export sections_flags
.export section_names

;*******************************************************************************
; SEGMENTS
; Segments define where the code or data that occupies them will be mapped to
; the memory defined in the SECTIONS blocks
; SEGMENTs may LOAD to one address but RUN in another. Note the corresponding
; bytes in the SEGMENT structure that select this.
;
; SEGMENTs have the format:
;  .byte[8] name
;  .byte    LOAD SEGMENT id
;  .byte    RUN SEGMENT id
;  .byte    flags
segments_load:   .res MAX_SEGMENTS ; id of section to load to
segments_run:    .res MAX_SEGMENTS ; id of section to run at
segments_flags:  .res MAX_SEGMENTS
segments_sizelo: .res MAX_SEGMENTS
segments_sizehi: .res MAX_SEGMENTS

; pointers for the current address of each SEGMENT during linking
segments_addrlo: .res MAX_SEGMENTS
segments_addrhi: .res MAX_SEGMENTS

segment_names: .res MAX_SEGMENT_NAME_LEN*MAX_SEGMENTS

.export segments_load
.export segments_run
.export segments_flags
.export segments_sizelo
.export segments_sizehi
.export segment_names

;*******************************************************************************
; SEGMENT MAP
; This array maps the index of a local SEGMENT to its global SEGMENT
; in the above tables.
; The indices into this array represent the id's used in the object file that
; is currently being linked.
segment_map: .res MAX_SEGMENTS

;*******************************************************************************
; OBJECT CODE overview
; Object code is stored in a simple block format as follows
;  - the 1st block contains all IMPORTs required to link the file
;  - the 2nd contains all EXPORTs exported by the file (and their offsets)
;  - the 3rd contains the SEGMENTs used and the # of bytes each uses
;  - the 4th contains the relocatable data
; Example:
;  IMP LAB1
;  IMP LAB2
;  EXP my_proc  CODE+$1000
;  EXP my_proc2 SETUP+$20
;
;  CODE $1032
;  DATA $0062
;
;  | Obj Code Def        | Description                               |
;  |-----------------------------------------------------------------|
;  | SEG CODE            | Switches to the CODE segment              |
;  | b $01 $33 $44       | defines bytes at CODE+0, CODE+1, CODE+2   |
;  | b $ad               | defines a byte at CODE+3                  |
;  | w LAB+3             | defines WORD with the value of LAB        |
;
; The value of segments (e.g. CODE) will change after each compilation unit
; is linked.
; After each file is linked, they are updated by the number of bytes produced
; for that segment by that unit.
; So if our unit has $200 bytes of code/data in its CODE segment, the
; hypothetical next unit will start assembling its CODE segment at CODE+$200
;
; Exports are calculated during linkage according to the current offset +
; SEGMENT values
;******************************************************************************

;******************************************************************************
; DEBUG FILE overview
; Debug (.d) files are binary files that contain the linked object code.
; They are similar to the object files that they are built from.
;
; Debug files cannot be run outside the Monster environment. To produce a
; standalone .PRG use dbg::linkprg
;
; EXAMPLE:
;  FILE NAMES:
;   hello.s
;   main.s
;
;  NUM_SYMBOLS: 4
;
;  SYMBOLS:
;   LAB1     CODE+$1600  hello.s L:120
;   LAB2     CODE+$1402  hello.s L:40
;   my_proc  CODE+$1000  main.s  L:200
;   my_proc2 SETUP+$20   main.s  L:10
;
;  SEGMENTS:
;   CODE $1032
;   DATA $062
;******************************************************************************

;******************************************************************************
; OBJ Code Opcodes
; These represent the "instruction" opcodes of the object code
OBJ_SETSEG  = $01       ; switches to the given segment e.g. "SEG DATA"
OBJ_BYTES   = $02 	; RLE encoded byte values e.g. "B 4 0 1 2 3"
OBJ_RELBYTE = $03	; byte value + word offset "RB LAB+3"
OBJ_RELWORD = $04	; word value + word offset "RW LAB+10"
OBJ_RELZP   = $05	; byte value followed by relative byte "RZ $20 LAB+10"
OBJ_RELABS  = $06	; byte value followed by relative word "RA $20 LAB+5"

.segment "LINKER"
;*******************************************************************************
; INIT
; Initializes the linker state
.export __link_init
.proc __link_init
@bss=r0
	; clear the LINKER_BSS segment
	ldxy #__LINKER_BSS_LOAD__
	stxy @bss

	lda #$00
@l0:	ldy #$00
	tya
	sta (@bss),y
	incw @bss
	ldxy @bss
	cmpw #__LINKER_BSS_LOAD__+__LINKER_BSS_SIZE__
	bne @l0

	rts
.endproc

;*******************************************************************************
; ADD EXPORT
; Adds the given string to the symbol table for the object file currently
; being constructed as an EXPORT
; IN:
;   - .XY: the name of the EXPORT to add
; OUT:
;   - .C: set on error (e.g. too many symbols)
; TODO: verify SYMBOL is not already IMPORTed or otherwise conflicting
.export __link_add_export
.proc __link_add_export
@export=r0
	ldx numsymbols
	cpx #MAX_SYMBOLS-1
	bcs @done			; too many symbols

	lda #SYM_REL_EXPORT_WORD	; TODO: handle other types
	sta symbol_info,x

	lda #$00
	sta @export+1

	txa
	asl		; *2
	asl		; *4
	asl		; *8
	asl		; *16
	rol @export+1
	asl		; *32
	rol @export+1
	adc #<symbol_names
	sta @export
	lda @export+1
	adc #>symbol_names
	sta @export+1

	; copy the symbol name into its location in the symbol_names table
	ldy #$00
@copy:	lda (zp::line),y
	jsr isseparator
	beq :+
	sta (@export),y
	bne @copy

:	inc numsymbols
	clc		; ok
@done:	rts
.endproc

;*******************************************************************************
; LINK OBJ
; Writes the current object file to the given filename.
; This is called after the first pass of the assembler to write all the exports,
; imports, and other header data to the object file.
; The assembler will then output the object code in pass 2.
; IN:
;   - .XY: the output filename
; OUT:
;   - .C: set on error
.export __link_obj
.proc __link_obj
@src=r0
@cnt=r2
	; open the output file for writing
	CALL FINAL_BANK_MAIN, file::open_w
	bcc @write_header
	rts			; failed to open file

@write_header:
	; write the SEGMENT block (segments used in the file)
	lda numsegments
	sta @cnt

	ldxy #@segment_names
	stxy @src
@segment_names:
	ldy #$00
:	lda (@src),y
	jsr $ffd2
	iny
	cpy #MAX_SEGMENT_NAME_LEN
	bcc :-
	lda @src
	clc
	adc #MAX_SEGMENT_NAME_LEN
	sta @src
	bcc :+
	inc @src+1
:	dec @cnt
	bne @segment_names

	; write the number of bytes used in each segment
	ldy #$00
@segment_sizes:
	lda segments_sizelo,y
	jsr $ffd2
	lda segments_sizehi,y
	jsr $ffd2
	iny
	cpy numsegments
	bcc @segment_sizes

	; write the SYMBOL TABLE
	jsr write_symtab

	; the OBJECT block (object code) will be written by the assembler
	RETURN_OK
.endproc

;*******************************************************************************
; LINK DEBUG
; Links the given object files into a .D (debug) file of the given name
; IN:
;  .XY:   the output filename of the .D (debug) file
;  r0:    the number of .O files
;  r1/r2: address of array of .O filenames (as 0-terminated strings)
.export __link_debug
.proc __link_debug
.endproc

;*******************************************************************************
; LINK PRG
; Links the given object files into a .PRG file of the given name
; IN:
;  .XY:   the output filename of the .PRG (PRG) file
;  r0:    the number of .O files
;  r1/r2: the array of .O filenames (as 0-terminated strings)
.export __link_prg
.proc __link_prg
.endproc

;*******************************************************************************
; PARSE LINK FILE
; Parses the given linker config file into sections and segments, loading
; those into the linker's own section and segment state.
; The file must follow the format:
;
; ```
; MEMORY [
; SECTIONA:
;  start=$0000
;  end=$1000
; SECTIONB:
;  ...
; ]
; SEGMENTS [
;  SEGA: load = SECTIONA
;  run = SECTIONB
;  type = [BSS, RO, RW]
; ]
; ```
;
; IN:
;  - .XY: pointer to the link filename
;  - .A:  length of the filename
; OUT:
;  - .C: set if the file could not be successfully opened or parsed
.export __link_parse
.proc __link_parse
@filebuff=mem::spare
@line=mem::linebuffer
@segments_declared=r8
@sections_declared=r9
	; setup the load address
	pha
	lda #<@filebuff
	sta file::loadaddr
	lda #>@filebuff
	sta file::loadaddr+1
	pla

	; load link file into filebuff
	CALL FINAL_BANK_MAIN, file::open_r
	CALL FINAL_BANK_MAIN, file::loadbin
	bcs @err

	ldxy #@filebuff
	stxy zp::line

	lda #$00
	sta @sections_declared
	sta @segments_declared

@getblock:
	; have all required blocks been declared?
	lda @sections_declared
	and @segments_declared
	beq @read_block

	; done; make sure there's no garbage after last ']'
	ldy #$00
:	lda (zp::line),y
	beq @done
	jsr is_ws
	bne @unexpected_char
	beq :-
@done:	RETURN_OK

@read_block:
	; look for MEMORY or SEGMENTS definition
	jsr process_ws
	ldy #$00

	; is line "MEMORY"?
	ldxy #@memory
	jsr cmpline
	beq @parse_sections

	; else is line "SEGMENTS"?
	ldxy #@segments
	jsr cmpline
	beq @parse_segments

	; invalid string
	sec
@err:	rts

@parse_sections:
	; make sure we haven't already declared sections
	lda @sections_declared
	beq :+
	sec
	rts			; err, sections already declared

:	; read past "MEMORY" declaration
	CALL FINAL_BANK_MAIN, line::process_word
	inc @sections_declared

	; look for the '['
	jsr @get_open_brace
	beq :+
@unexpected_char:
	RETURN_ERR ERR_UNEXPECTED_CHAR

	; read the section into the section definitions table
:	incw zp::line		; move beyond the '['
	jsr process_ws
@l0:	jsr parse_section
	bcs @err		; -> rts
	inc numsections		; SECTION was successfully parsed

	jsr @get_closing_brace
	bne @l0			; if not ']', read next section
	incw zp::line		; else, move over the ']'
	bne @getblock		; and get the next block (SEGMENTS)

@parse_segments:
	; make sure SEGMENTS weren't already declared
	lda @segments_declared
	beq :+
	sec
	rts			; err, sections already declared

:	; read past "SEGMENTS"
	CALL FINAL_BANK_MAIN, line::process_word
	inc @segments_declared

	; look for the '['
	jsr @get_open_brace
	beq :+
	RETURN_ERR ERR_UNEXPECTED_CHAR

	; read the section into the section definitions table
:	incw zp::line		; move beyond the '['
	jsr process_ws
@l1:	jsr parse_segment
	bcs @err		; -> rts
	inc numsegments		; SEGMENT was successfully parsed
	jsr @get_closing_brace
	bne @l1			; if not ']', read next segment
	incw zp::line		; else, move over the ']'
	jmp @getblock		; and get next block (SECTIONS)

; return .Z set if first non-whitespace char is a '['
@get_open_brace:
	jsr process_ws
	ldy #$00
	lda (zp::line),y
	cmp #'['
	rts

; return .Z set if first non-whitespace char is a ']'
@get_closing_brace:
	jsr process_ws
	ldy #$00
	lda (zp::line),y
	cmp #']'
	rts

@memory:   .byte "memory",0
@segments: .byte "segments",0
.endproc

;*******************************************************************************
; PARSE SECTION
; Parses the definition for one SECTION in the MEMORY block of the linker file
; A section is defined by the section name followed by a ':'
; Followed by lines defining its start and end address
;
; SECTIONA:
;  start=$0000
;  end=$1000
;  fill=1
;
; IN:
;  - zp::line: points to the buffer to parse the SECTION from
; OUT:
;  - .C: set if section could not be parsed
.proc parse_section
@name=r0
@val=r2
@cnt=r4
@keybuff=$100
	; get address to store new section name to
	lda numsections
	asl			; *2
	asl			; *4
	asl			; *8
	adc #<section_names
	sta @name
	lda #>section_names
	adc #$00
	sta @name+1

	; read the section name (string terminated by ':')
	jsr process_ws
	ldy #$00
@l0:	lda (zp::line),y
	bne :+
@err:   RETURN_ERR ERR_UNEXPECTED_CHAR	; line ended without ':'
:	cmp #$0d
	beq @err
	cmp #$0a
	beq @err
	cmp #':'
	beq @cont			; found end of section name
	sta (@name),y
	iny
	cpy #$08
	bcc @l0
	RETURN_ERR ERR_LABEL_TOO_LONG	; section name > 8 chars

@cont:	tya
	;sec			; +1 (move pointer after the ':')
	adc zp::line
	sta zp::line
	bcc @getprops
	inc zp::line+1

; read all properties defined for the SECTION
@getprops:
	jsr process_ws		; move the key name in section

	ldy #$00
	lda (zp::line),y
	cmp #';'		; are we at the end of the section?
	bne :+
	incw zp::line		; move beyond the semicolon
	RETURN_OK		; we're at the end, return

:	; read the key of the k/v pair into keybuffer
	ldxy #@keybuff
	jsr readkey
	bcs @err

@keyfound:
	ldxy #@keybuff
	stxy zp::str0

	; find the key that corresponds to the one in the config file
	ldxy #@keys
	stxy zp::str2

	lda #$00
	sta @cnt
@findkey:
	jsr strcmp
	bne @next

@found: ; found the key, run the command to map it
	ldx @cnt
	lda @cmdslo,x
	sta zp::jmpvec
	lda @cmdshi,x
	sta zp::jmpvec+1

	; evaluate the value for the handler
	jsr parse_val
	bcs @ret	; error -> rts

	; run the handler for the given key
	jsr zp::jmpaddr
	jmp @getprops	; repeat (get next key if there is one)

@next:	; move zp::str2 to the next key to check
	ldy #$00
:	lda (zp::str2),y
	incw zp::str2
	cmp #$00
	bne :-

	; are we out of keys?
	inc @cnt
	lda @cnt
	cmp #@numkeys
	bne @findkey

	; sec (unknown key)
@ret:	rts

;--------------------------------------
; handler for the "start" key in config file
@startvec:
	; set the start address for the segment
	txa
	ldx numsections
	sta sections_startlo,x
	tya
	sta sections_starthi,x
	rts

;--------------------------------------
; handler for the "stop" key in config file
@endvec:
	; set the end address for the segment
	txa
	ldx numsections
	sta sections_stoplo,x
	tya
	sta sections_stophi,x
	rts

;--------------------------------------
; handler for the "fill" key in config file
@fillvec:
	ldx numsections
	lda #SECTION_FILL
	sta sections_flags,x
	rts

;--------------------------------------
; keys table
@keys:
@numkeys=3
@start:	.byte "start",0
@end:	.byte "end",0
@fill:	.byte "fill",0

;--------------------------------------
; keys table handler vectors
.define sec_cmds @startvec, @endvec, @fillvec
@cmdslo: .lobytes sec_cmds
@cmdshi: .hibytes sec_cmds

.endproc

;*******************************************************************************
; PARSE SEGMENT
; Parses the definition for one SEGMENT in the SEGMENTS block of the linker file
; A segment is defined by the section name followed by a ':'
; Followed by lines defining its load and run addresses
; SEGA:
;  load=$0000
;  run=$1000
; IN:
;  - zp::line: points to the buffer to parse the SEGMENT from
; OUT:
;  - .C: set if the segment could not be parsed
.proc parse_segment
@name=r0
@val=r2
@cnt=r4
@keybuff=$100
@sec=$100
	; get address to store new segment name to
	lda numsegments
	asl			; *2
	asl			; *4
	asl			; *8
	adc #<segment_names
	sta @name
	lda #>segment_names
	adc #$00
	sta @name+1

	; read the segment name (string terminated by ':')
	jsr process_ws
	ldy #$00
@l0:	lda (zp::line),y
	bne :+
@err:   RETURN_ERR ERR_UNEXPECTED_CHAR	; line ended without ':'
:	cmp #$0d
	beq @err
	cmp #$0a
	beq @err
	cmp #':'
	beq @cont			; found end of section name
	sta (@name),y
	iny
	cpy #$08
	bcc @l0
	RETURN_ERR ERR_LABEL_TOO_LONG	; section name > 8 chars

@cont:	tya
	;sec			; +1 (move pointer after the ':')
	adc zp::line
	sta zp::line
	bcc @getprops
	inc zp::line+1

; read all properties defined for the SEGMENT
@getprops:
	jsr process_ws		; move the key name in segment

	ldy #$00
	lda (zp::line),y
	cmp #';'		; are we at the end of the segment?
	bne :+
	incw zp::line		; move beyond the semicolon
	RETURN_OK		; we're at the end, return

:	; read the key of the k/v pair into keybuffer
	ldxy #@keybuff
	jsr readkey
	bcs @err

@keyfound:
	ldxy #@keybuff
	stxy zp::str0

	; find the key that corresponds to the one in the config file
	ldxy #@keys
	stxy zp::str2

	lda #$00
	sta @cnt
@findkey:
	jsr strcmp
	bne @next

@found: ; found the key, run the command to map it
	ldx @cnt
	lda @cmdslo,x
	sta zp::jmpvec
	lda @cmdshi,x
	sta zp::jmpvec+1

	; get the section ID from the value (string)
	; first, read the section name into a temp buffer
	ldy #$00
:	lda (zp::line),y
	beq @get_section
	cmp #';'
	beq @get_section
	jsr is_ws
	beq @get_section
	sta @sec,y
	iny
	bne :-

@get_section:
	lda #$00
	sta @sec,y	; terminate the section name buffer

	; update line pointer to after the name that was read
	tya
	clc
	adc zp::line
	sta zp::line
	bcc :+
	inc zp::line+1

:	; get the section ID
	ldxy #@sec
	jsr get_section_by_name
	bcs @ret		; section not found -> rts

	; .A = .XY = section ID
	tax
	ldy #$00

	; run the handler for the given key
	jsr zp::jmpaddr
	jmp @getprops	; repeat (get next key if there is one)

@next:	; move zp::str2 to the next key to check
	ldy #$00
:	lda (zp::str2),y
	incw zp::str2
	cmp #$00
	bne :-

	; are we out of keys?
	inc @cnt
	lda @cnt
	cmp #@numkeys
	bne @findkey

	; sec (unknown key)
@ret:	rts

;--------------------------------------
; handler for the "run" key in SEGMENT
@runvec:
	; set the run section for the segment
	ldx numsegments
	sta segments_load,x
	rts

;--------------------------------------
; handler for the "load" key in SEGMENT
@loadvec:
	; set the load section for the segment
	ldx numsegments
	sta segments_run,x
	rts

;--------------------------------------
; keys table
@numkeys=2
@keys:
@load:     .byte "load",0
@run:      .byte "run",0

;--------------------------------------
; keys table handler vectors
.define seg_cmds @runvec, @loadvec
@cmdslo: .lobytes seg_cmds
@cmdshi: .hibytes seg_cmds

.endproc

;*******************************************************************************
; LINK
; Links all files that were added to the linker (link::addfile) and produces
; the linked executable as a file with the given name.
; IN:
;  - .XY:            the filename to produce from the linked files
;  - .A:             the number of input files
;  - link::objfiles: array of the files to link
; OUT:
;  - .C: set on error
.export __link_link
.proc __link_link
@filename=zp::link
	stxy @filename

	; init the segment/section pointers using the current linker state
	; (parsed from the LINK file prior to calling this procedured)
	ldx numsegments
	bne @initsegments

	sec		; no segments defined; return error
	rts

@initsegments:
	dex
@l0:	ldy segments_load,x
	lda sections_startlo,y
	sta segments_addrlo,x
	lda sections_starthi,y
	sta segments_addrhi,x
	dex
	bpl @l0

	; load each .O (object) file

	; extract header data foreach file and update pointers to each file
	; to the main block of the .O file
	jsr extract_headers

	; now that we have the sizes of each SEGMENT, build the start
	; addresses of each segment and update SECTION start pointer by the
	; SIZE of the SEGMENT we've assigned to that SECTION.
	; TODO:

	; make sure START is still less than STOP for the SECTION
	; TODO:
@err:	RETURN_ERR ERR_SECTION_TOO_SMALL

; iterate over each object file and link them
@objects:
	lda #$00
	jsr link_object		; link the object
	bcs @done		; if .C set, return with error
	inc activeobj		; next object
	lda activeobj
	cmp numobjects
	bne @objects
	clc			; success
@done:	rts
.endproc

;*******************************************************************************
; LINK OBJECT
; Handles the main block of the object code defintion using the data extracted
; from the OBJ headers.
.proc link_object
	ldx activeobj

@l0:	ldy #$00
	lda (objptr),y	; get an "instruction" from the OBJ code
	incw objptr	; move past "opcode"
	clc
	beq @done	; if we read a 0, we're at the end of the "program"

	lda @cmdslo,x
	sta zp::jmpvec
	lda @cmdshi,x
	sta zp::jmpvec+1

	; run the "instruction"
	jsr zp::jmpaddr
	jmp @l0		; continue to the next instruction
@done:	rts

.linecont +
.define op_vecs set_seg, obj_bytes, obj_rel_byte, obj_rel_word, obj_rel_zp, \
	obj_rel_abs
.linecont -
@cmdslo: .lobytes op_vecs
@cmdshi: .hibytes op_vecs
.endproc

;*******************************************************************************
; OBJ BYTES
; Handles the OBJ_BYTES command
; Assembles the bytes that follow to the address of the current segment pointer,
; which is updated upon doing so
.proc obj_bytes
@ptr=r0
@cnt=r2
	ldy #$00
	lda (objptr),y ; read the number of bytes to output
	sta @cnt

	incw objptr
	lda (objptr),y ; read the number of bytes to output (hi)
	sta @cnt+1

	incw objptr

@l0:	lda (objptr),y	; get the byte to write to the binary
	sta (segptr),y	; output the byte from the object file
	incw segptr
	incw objptr
	decw @cnt
	bne @l0

	rts
.endproc

;*******************************************************************************
; OBJ REL BYTE
.proc obj_rel_byte
.endproc

;*******************************************************************************
; OBJ REL ZP
.proc obj_rel_zp
.endproc

;*******************************************************************************
; OBJ REL ABS
.proc obj_rel_abs
.endproc

;*******************************************************************************
; OBJ REL WORD
; Handles the OBJ_REL_WORD command
; Inserts a WORD with the value of the symobl that follows + an offset to
; the current address of the segment pointer
; A textual representation of this command looks like this:
;  `RW LABEL 12`
; LABEL is defined in the IMPORT section for the object code, so its binary
; representation refers to the offset in the IMPORT table
; The binary representation of the above command looks like this:
;  ` $02 $0030 $0c`
.proc obj_rel_word
@tmp=r0
	ldy #$00
	lda (objptr),y
	sta @tmp
	incw objptr
	lda (objptr),y
	sta @tmp+1
	incw objptr

	; add the offset
	lda (objptr),y
	clc
	adc @tmp
	sta (segptr),y
	iny
	lda (objptr),y
	adc @tmp+1
	sta (segptr),y

	; update object code and segment pointers
	incw objptr
	incw segptr
	incw objptr
	incw segptr
	rts
.endproc

;******************************************************************************
; SET SEG
; Sets the segment to the given segment name
; e.g.
;  SEG "DATA"
; The binary representatino is similar
;  $03 "DATA",0
; Where $03 is the binary opcode for "SEG" and "DATA" is still the literal
; segment data (0-terminated)
; IN:
;  - objptr: the current pointer in the object code
.proc set_seg
	; update the current end address of the active segment
	ldx activeseg
	lda segptr
	sta segments_addrlo,x
	lda segptr+1
	sta segments_addrhi,x

	; get the operand (SEGMENT id)
	ldxy objptr
	jsr get_segment_by_name
	bcs @done		; return error if not found
	sta activeseg
	tax
	lda segments_addrlo,x
	sta segptr
	lda segments_addrhi,x
	sta segptr+1

	; move past the name
	ldy #$ff
:	iny
	lda (objptr),y
	bne :-

	tya
	sec			; +1 (get past the 0)
	adc objptr
	bcc @done
	inc objptr+1
@done:	rts
.endproc

;*******************************************************************************
; EXTRACT HEADERS
; Extracts the header data from the .obj file and builds the absolute address
; of any EXPORTs for the .obj file. These are added as labels (lbl::add).
; Then updates the SEGMENT pointers by the sizes of each SEGMENT used in the
; .obj file.
;
; The first block contains the names of all segments used in the object file.
; This is a list of 0-terminated strings.
; ---------------------------------
; |  Property       | Size (bytes)|
; |-----------------|-------------|
; | Segment 0 Name  |  1-32       |
; | Segment 1 Name  |  1-32       |
; | end marker (0)  |  1          |
; ---------------------------------
;
; The next block contains the SYMBOL table for the block
; Exported symbols may be relative to a SEGMENT. To identify the SEGMENT
; they contain a 1 byte ID, which refers to their index in the segment
; table for the object file
;
; -----------------------------------------------
; |  Property                     | Size (bytes)|
; |-------------------------------|-------------|
; | Symbol 0 Name                 |  1-32       |
; | Symbol 0 Type                 |  1-32       |
; | (if export: Export 0 Segment) |    1        |
; | (if export: Export 0 Offset)  |    2        |
; | Symbol 1 Name                 |  1-32       |
; | Symbol 1 Type                 |  1-32       |
; | (if export: Export 1 Segment) |    1        |
; | (if export: Export 1 Offset)  |    2        |
; -----------------------------------------------
;
; The next block of headers tells the linker the name and size of each SEGMENT
; in the .obj file
; --------------------------------
; |  Property      | Size (bytes)|
; |----------------|-------------|
; | SEG1 name      |  16         |
; | sizeof(SEG1)   |  2          |
; | SEG2 name      |  16         |
; | sizeof(SEG2)   |  2          |
; | end marker (0) |  1          |
; --------------------------------
;
; IN:
;  - .XY: address to the contents of the .obj file
; OUT:
;  - .XY:             address of the remainder of the .obj file (after headers)
;  - segments_stoplo: updated with new LSBs of end of affected segments
;  - segments_stophi: updated with new MSBs of end of affected segments
;  - labels:          updated with any EXPORTed symbols from .obj file
.proc extract_headers
EXPORT_SEG  = 8 		; offset to SEGMENT name in IMPORT header
EXPORT_SIZE = 8+8		; offset to SIZE in IMPORT header
EXPORT_BLOCK_ITEM_SIZE = 8 + EXPORT_SEG + EXPORT_SIZE
@fptr=r0
@segaddr=r2
@buff=r4
	stxy @fptr
	ldx numfiles
@getsegments:

@getsymbols:
	; get the absolute address of the segment
	lda #EXPORT_SEG
	clc
	adc @buff
	tax
	lda @buff+1
	adc #$00
	tay
	jsr get_segment_by_name
	stxy @segaddr

	; calclulate the absolute address for the EXPORT
	ldy #EXPORT_SIZE
	lda (@buff),y
	clc
	adc @segaddr
	sta zp::label_value
	iny
	lda (@buff),y
	adc @segaddr+1
	sta zp::label_value+1

	ldxy #@buff	; name of the EXPORT
	jsr lbl::add	; add the EXPORT to the symbol table

	; move fptr to next EXPORT or block
	lda @fptr
	clc
	adc #EXPORT_BLOCK_ITEM_SIZE
	sta @fptr
	bcc :+
	inc @fptr
:	ldy #$00
	lda (@fptr),y
	bne @getsymbols ; if not end of block, continue
	incw @fptr	; move past terminating 0

; sum the SEGMENT sizes for the header with our existing sizes for those
; segments and set the STOP addresses accordingly
@updatesegments:
	ldxy #@fptr		; SEGMENT name
	jsr get_segment_by_name
	tax
	ldy #8			; offset to SIZE
	lda (@fptr),y
	clc
	adc segments_sizelo,x
	sta segments_sizelo,x
	iny
	lda (@fptr),y
	adc segments_sizehi,x
	sta segments_sizehi,x

	lda @fptr
	adc #10			; sizeof(NAME) + sizeof(SIZE)
	sta @fptr
	bcc :+
	inc @fptr+1
:	ldy #$00
	lda (@fptr),y
	bne @updatesegments	; loop if not end of SEGMENT block

	incw @fptr
	ldxy @fptr
	rts
.endproc

;*******************************************************************************
; GEN SEGMENT MAP
; Read the IMPORT block from the open OBJECT file and
.proc gen_segment_map
.endproc

;******************************************************************************
; GET SECTION BY NAME
; Returns the ID of the section from its name
; IN:
;  - .XY: the name of the section
; OUT:
;  - .A: the ID of the section
;  - .C: set if no segment exists by the given name
.proc get_section_by_name
@name=zp::str0
@other=zp::str2
@cnt=r0
	stxy @name
	ldxy #section_names
	stxy @other

	lda #$00
	sta @cnt
@l0:	lda #$08
	jsr strcmp
	beq @found
	lda @other
	clc
	adc #$08
	sta @other
	ldx @cnt
	inx
	stx @cnt
	cpx numsections
	bcc @l0
@notfound:
	rts

@found: lda @cnt
	RETURN_OK
.endproc

;******************************************************************************
; GET SEGMENT BY NAME
; Returns the ID of the segment from its name
; IN:
;  - .XY: the name of the segment
; OUT:
;  - .A: the ID of the segment
;  - .C: set if no segment exists by the given name
.proc get_segment_by_name
@name=zp::str0
@other=zp::str2
@cnt=r0
	stxy @name
	ldxy #segment_names
	stxy @other

	lda #$00
	sta @cnt
@l0:	lda #$08
	jsr strcmp
	beq @found
	lda @other
	clc
	adc #$08
	sta @other
	ldx @cnt
	inx
	stx @cnt
	cpx numsegments
	bcc @l0
@notfound:
	rts

@found: lda @cnt
	RETURN_OK
.endproc

;*******************************************************************************
; EMITB
; Outputs an instruction to write a direct value to the open object file
; IN:
;  - .A: the byte to write
; OUT:
;  - .C: set on error
.export __link_emitb
.proc __link_emitb
	pha
	lda #I_EMIT_BYTE
	jsr $ffd2
	pla
	jmp $ffd2	; CHROUT
.endproc

;******************************************************************************
; WRITE SYMTAB
; Writes all symbols to the symbol table, thus generating the symbol table for
; the object file
.export write_symtab
.proc write_symtab
@cnt=r0
@name=r2
	ldxy #symbol_names
	stxy @name
	ldx #$00

@l0:	ldy #$00

	; write the symbol name to the object file
@l1:	lda (@name),y
	beq :+
	jsr $ffd2
	iny
	cpy #MAX_SYMBOL_NAME_LEN
	bcc @l1

:	; write the symbol type identifier
	lda symbol_info,x
	jsr $ffd2

	; if the symbol is an IMPORT, we're done with this one
	cmp #SYM_IMPORT_BYTE
	beq @next
	cmp #SYM_IMPORT_WORD
	beq @next

	; if symbol is an EXPORT, write the SEGMENT ID and SEGMENT OFFSET
	lda symbol_segment_ids,x
	jsr $ffd2
	lda symbol_offsetslo,x
	jsr $ffd2
	lda symbol_offsetshi,x
	jsr $ffd2

@next:	lda @name
	clc
	adc #MAX_SYMBOL_NAME_LEN
	sta @name
	bcc :+
	inc @name+1

:	inx
	cpx numsymbols
	bne @l0

	RETURN_OK
.endproc

;*******************************************************************************
; READ KEY
; Read the key in a key/value pair into the given buffer
; A key/value pair is a string and value separated by an '=' sign
; IN:
;   - zp::line: the buffer to read the key from
;   - .XY:      the address to read the key into
; OUT:
;   - zp::line: updated to point after the '=' in the key/value pair
;   - .C:       set if the input buffer is not a valid key/value pair
.proc readkey
@buff=r0
	stxy @buff

	ldy #$00
@l0:	lda (zp::line),y
	cmp #$0d
	beq @err	; unexpected newline
	cmp #$0a
	beq @err	; unexpected newline
	cmp #'='
	beq @done	; found end of key definition
	sta (@buff),y
	iny
	cpy #8
	bcc @l0
	RETURN_ERR ERR_LABEL_TOO_LONG

@done:	lda #$00
	sta (@buff),y	; terminate bufffer
	tya
	sec		; +1
	adc zp::line
	sta zp::line
	bcc :+
	inc zp::line+1
:	RETURN_OK

@err:	RETURN_ERR ERR_UNEXPECTED_CHAR
.endproc

;*******************************************************************************
; PARSE VAL
; Parses the value from the key/value pair
; e.g. A=120
; IN:
;   - zp::line: points to the value of a key/value pair
; OUT:
;   - zp::line: points after the value in the buffer
;   - .XY:      the value of the key/value pair
;   - .C:       set if the key/value pair was not parsed successfully
.proc parse_val
@val=r0
@buff=$100
	jsr process_ws

	; read the value into a temporary buffer
@l0:	lda (zp::line),y
	beq :+
	cmp #$0d
	beq :+
	cmp #$0a
	beq :+
	cmp #';'	; SEGMENT/SECTION terminator
	beq :+
	sta @buff,y
	iny
	bne @l0

:	lda #$00
	sta @buff,y
	tay

	; check if the value is hex or decimal
	lda (zp::line),y
	cmp #'$'
	beq @hex

@dec:	ldxy #@buff
	CALL FINAL_BANK_MAIN, atoi
	bcc @cont
	rts			; error

@hex:	; get the value of the value string
	ldxy #@buff+1		; +1 to get after the '$'
	CALL FINAL_BANK_MAIN, util::parsehex
	bcs @ret

@cont:	stxy @val
	; move beyond the value string (to start of next word or ';')
	ldy #$00
:	lda (zp::line),y
	cmp #$0a
	beq @done
	cmp #$0d
	beq @done
	cmp #';'
	beq @done
	iny
	jsr is_ws
	bne :-

@done:	tya
	clc
	adc zp::line
	sta zp::line
	bcc :+
	inc zp::line+1
:	ldxy @val
	clc		; ok
@ret:	rts
.endproc

;*******************************************************************************
; COMPARE LINE
; Compares the strings in (zp::line) and (.XY) up to a length of .A
.proc cmpline
	stxy zp::str2
	ldxy zp::line
	stxy zp::str0

	; fall through to strcmp
.endproc

;*******************************************************************************
; COMPARE
; Compares the strings in (zp::str0) and (zp::str2) up to a length of .A
; IN:
;  zp::str0: one of the strings to compare
;  zp::str1: the other string to compare
; OUT:
;  .Z: set if the strings are equal
.proc strcmp
	ldy #$00
@l0:	lda (zp::str0),y
	beq :+
	jsr is_ws
	beq :+
	cmp (zp::str2),y
	bne @ret
	iny
	bne @l0

:	lda (zp::str2),y	; make sure strings terminate at same index
@ret:	rts
.endproc

;*******************************************************************************
; PROCESS WS
; Reads (line) and updates it to point past ' ' chars and non-printing chars
; out:
;  .Z: set if we're at the end of the line
;  .A: the last character processed
;  .Y: 0
;  zp::line: updated to first non ' ' character
.proc process_ws
	ldy #$00
@l0:	lda (zp::line),y
	beq @done		; if end of line, we're done
	bmi @skip		; skip non-printing chars
	jsr is_ws
	bne @done		; if not space, we're done
@skip:	incw zp::line
	bne @l0
@done:	rts
.endproc

;*******************************************************************************
; IS WS
; Checks if the given character is a whitespace character
; IN:
;  - .A: the character to test
; OUT:
;  - .Z: set if if the character in .A is whitespace
.proc is_ws
	cmp #$0d	; newline
	beq :+
	cmp #$09	; TAB
	beq :+
	cmp #$0a
	beq :+
	cmp #' '
:	rts
.endproc

;******************************************************************************
; IS NULL SPACE COMMA CLOSINGPAREN
; IN:
;  - .A: the character to test
; OUT:
;  - .Z: set if the char in .A is: 0,$0d,' ', ',', or ')'
.proc is_null_return_space_comma_closingparen_newline
	cmp #$00
	beq @done
	jsr is_ws
	beq @done
	cmp #','
	beq @done
	cmp #')'
@done:	rts
.endproc

;******************************************************************************
; IS OPERATOR
; IN:
;  - .A: the character to test
; OUT:
;  - .Z: set if the char in .A is an operator ('+', '-', etc.)
.proc isoperator
@xsave=zp::util+2
	stx @xsave
	ldx #@numops-1
:	cmp @ops,x
	beq @end
	dex
	bpl :-
@end:	php
	ldx @xsave
	plp
	rts
@ops: 	.byte '(', ')', '+', '-', '*', '/', '[', ']', '^', '&', '.'
@numops = *-@ops
.endproc

;******************************************************************************
; ISSEPARATOR
; IN:
;  - .A: the character to test
; OUT:
;  - .Z: set if the char in .A is any separator
.proc isseparator
	cmp #':'
	beq @yes
	jsr is_null_return_space_comma_closingparen_newline
	bne :+
@yes:	rts
:	jmp isoperator
.endproc
