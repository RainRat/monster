;*******************************************************************************
; LINKER.ASM
; The linker links the object code generated by the assembler into a binary
; (.prg or plain) or debug (.d) file.
;
; See the OBJECT CODE overview below for details on the object format.
;*******************************************************************************
.include "errors.inc"
.include "file.inc"
.include "labels.inc"
.include "line.inc"
.include "macros.inc"
.include "memory.inc"
.include "object.inc"
.include "string.inc"
.include "strings.inc"
.include "util.inc"
.include "zeropage.inc"

.include "ram.inc"

.import __LINKER_BSS_LOAD__
.import __LINKER_BSS_SIZE__

;*******************************************************************************
; CONSTANTS
MAX_SECTIONS         = 8	; max number of memory sections
MAX_SEGMENTS         = 8	; max number of segments across all objects
MAX_OBJS             = 16	; max number of object files that may be used
MAX_SECTION_NAME_LEN = 8	; max length of a single section name
MAX_SEGMENT_NAME_LEN = 8	; max length of a single segment name

MAX_SYMBOL_NAME_LEN = 32
MAX_SYMBOLS         = 128	; max # of symbols per object file

SYM_IMPORT_BYTE     = 1
SYM_IMPORT_WORD     = 2
SYM_REL_EXPORT_BYTE = 3
SYM_REL_EXPORT_WORD = 4
SYM_ABS_EXPORT_BYTE = 5
SYM_ABS_EXPORT_WORD = 6

;*******************************************************************************
; SECTION flags
SECTION_FILL = $01	; flag to pad section's unused bytes with 0

;*******************************************************************************
; SEGMENT flags
SEGMENT_RO     = $01	; RO (readonly) writes to segment will be error
SEGMENT_DEFINE = $02

;*******************************************************************************
; INSTRUCTION OPCODES
I_SET_SEG   = 1
I_EMIT_BYTE = 2

;*******************************************************************************
; ZEROPAGE variables
; OBJPTR is the cursor in the object code (where we are reading in the current
; object file)
; SEGPTR is the cursor to the .PRG or .D file (where we are WRITIING)
objptr=zp::link
segptr=zp::link+2

;*******************************************************************************
; OBJFILES
; The list of object files to link
; Represented as a 0-terminated list of 0-terminated filename
; e.g.
;   "FILE1.O",0,"FILE2.O",0,0
.export __link_outfile
__link_outfile=mem::spare

.export __link_objfiles
__link_objfiles=mem::spare+16

;*******************************************************************************
.segment "LINKER_BSS"

numobjects:  .byte 0
numsegments: .byte 0
numsections: .byte 0
numfiles:    .byte 0

activeobj: .byte 0	; the current OBJECT (id) being linked
activeseg: .byte 0	; the current SEGMENT (id) being written

;*******************************************************************************
; OBJECT STATE
; These variables are used in the context of a single object file
numsymbols:  .byte 0

;*******************************************************************************
; SYMBOL NAMES
; This table contains the name for each symbol used in the object file
symbol_names:
.ifdef vic20
	.res MAX_SYMBOLS*MAX_SYMBOL_NAME_LEN
.else
.endif

;*******************************************************************************
; SYMBOL INFO
; This table contains corresponding flags for each symbol.
; It defines the type of symbol in the object file.
;  - ABS RELATIVE: an exported symbol with an relative (from SEGMENT) value
;    e.g. ```
;         .export LABEL
;         LABEL:
;         ````
;  - ABS EXPORT: an exported symbol with an absolute value
;    e.g. ```
;         .export LABEL
;         LABEL=$100
;         ````
;  - IMPORT: a symbol that is used in the object file but defined in another
;    e.g. ```
;         .IMPORT LABEL
;         jsr LABEL
;         ```
symbol_info:
.ifdef vic20
	.res MAX_SYMBOLS
.else
.endif

;*******************************************************************************
; SYMBOL SEGMENT IDS
; This table contains the index of each SYMBOL to its SEGMENT in the SEGMENTS
; table.
symbol_segment_ids:
.ifdef vic20
	.res MAX_SYMBOLS
.else
.endif

;*******************************************************************************
; SYMBOL OFFSETS
; This table contains the relative offsets for each symbol from their
; designated SEGMENTs (identified in the SEGMENT IDs table).
symbol_offsetslo:
.ifdef vic20
	.res MAX_SYMBOLS
.else
.endif

symbol_offsetshi:
.ifdef vic20
	.res MAX_SYMBOLS
.else

.endif

;*******************************************************************************
; SECTIONS
; The memory section contains up to MAX_SECTIONS of memory blocks.  Each
; defines the start and end addresses of the section plus a byte of flag
; data, which is used to, for example, flag that the section should be padded
; if the SEGMENTs that map to this section do not span the entire
; [start, stop] address space.
; The format of a SECTION is:
;  .word start addr
;  .word stop addr
;  .byte flags
sections_startlo: .res MAX_SECTIONS
sections_starthi: .res MAX_SECTIONS
sections_stoplo:  .res MAX_SECTIONS
sections_stophi:  .res MAX_SECTIONS
sections_flags:   .res MAX_SECTIONS
section_names:    .res MAX_SECTIONS*MAX_SECTION_NAME_LEN

.export sections_startlo
.export sections_starthi
.export sections_stoplo
.export sections_stophi
.export sections_flags
.export section_names

;*******************************************************************************
; SEGMENTS
; Segments define where the code or data that occupies them will be mapped to
; the memory defined in the SECTIONS blocks
; SEGMENTs may LOAD to one address but RUN in another. Note the corresponding
; bytes in the SEGMENT structure that select this.
;
; SEGMENTs have the format:
;  .byte[8] name
;  .byte    LOAD SEGMENT id
;  .byte    RUN SEGMENT id
;  .byte    flags
segments_load:   .res MAX_SEGMENTS	; id of section to load to
segments_run:    .res MAX_SEGMENTS	; id of section to run at
segments_flags:  .res MAX_SEGMENTS
segments_sizelo: .res MAX_SEGMENTS
segments_sizehi: .res MAX_SEGMENTS

; pointers for the current address of each SEGMENT during linking
segments_addrlo: .res MAX_SEGMENTS
segments_addrhi: .res MAX_SEGMENTS

segment_names: .res MAX_SEGMENT_NAME_LEN*MAX_SEGMENTS

.export segments_load
.export segments_run
.export segments_flags
.export segments_sizelo
.export segments_sizehi
.export segment_names

; base addresses for each segment per file
file_segments_startlo: .res MAX_OBJS*MAX_SECTIONS
file_segments_starthi: .res MAX_OBJS*MAX_SECTIONS

;*******************************************************************************
; SEGMENT MAP
; This array maps the index of a local SEGMENT to its global SEGMENT
; in the above tables.
; The indices into this array represent the id's used in the object file that
; is currently being linked.
segment_map: .res MAX_SEGMENTS

;*******************************************************************************
; OBJECT CODE overview
; Object code is stored in a simple block format as follows
;  - the 1st block contains all IMPORTs required to link the file
;  - the 2nd contains all EXPORTs exported by the file (and their offsets)
;  - the 3rd contains the SEGMENTs used and the # of bytes each uses
;  - the 4th contains the relocatable data
; Example:
;  IMP LAB1
;  IMP LAB2
;  EXP my_proc  CODE+$1000
;  EXP my_proc2 SETUP+$20
;
;  CODE $1032
;  DATA $0062
;
;  | Obj Code Def        | Description                               |
;  |-----------------------------------------------------------------|
;  | SEG CODE            | Switches to the CODE segment              |
;  | b $01 $33 $44       | defines bytes at CODE+0, CODE+1, CODE+2   |
;  | b $ad               | defines a byte at CODE+3                  |
;  | w LAB+3             | defines WORD with the value of LAB        |
;
; The value of segments (e.g. CODE) will change after each compilation unit
; is linked.
; After each file is linked, they are updated by the number of bytes produced
; for that segment by that unit.
; So if our unit has $200 bytes of code/data in its CODE segment, the
; hypothetical next unit will start assembling its CODE segment at CODE+$200
;
; Exports are calculated during linkage according to the current offset +
; SEGMENT values
;******************************************************************************

;******************************************************************************
; DEBUG FILE overview
; Debug (.d) files are binary files that contain the linked object code.
; They are similar to the object files that they are built from.
;
; Debug files cannot be run outside the Monster environment. To produce a
; standalone .PRG use dbg::linkprg
;
; EXAMPLE:
;  FILE NAMES:
;   hello.s
;   main.s
;
;  NUM_SYMBOLS: 4
;
;  SYMBOLS:
;   LAB1     CODE+$1600  hello.s L:120
;   LAB2     CODE+$1402  hello.s L:40
;   my_proc  CODE+$1000  main.s  L:200
;   my_proc2 SETUP+$20   main.s  L:10
;
;  SEGMENTS:
;   CODE $1032
;   DATA $062
;******************************************************************************

;******************************************************************************
; OBJ Code Opcodes
; These represent the "instruction" opcodes of the object code
OBJ_SETSEG  = $01       ; switches to the given segment e.g. "SEG DATA"
OBJ_BYTES   = $02 	; RLE encoded byte values e.g. "B 4 0 1 2 3"
OBJ_RELBYTE = $03	; byte value + word offset "RB LAB+3"
OBJ_RELWORD = $04	; word value + word offset "RW LAB+10"
OBJ_RELZP   = $05	; byte value followed by relative byte "RZ $20 LAB+10"
OBJ_RELABS  = $06	; byte value followed by relative word "RA $20 LAB+5"

.segment "LINKER"
;*******************************************************************************
; INIT
; Initializes the linker state
.export __link_init
.proc __link_init
@bss=r0
	; clear the LINKER_BSS segment
	ldxy #__LINKER_BSS_LOAD__
	stxy @bss

	lda #$00
@l0:	ldy #$00
	tya
	sta (@bss),y
	incw @bss
	ldxy @bss
	cmpw #__LINKER_BSS_LOAD__+__LINKER_BSS_SIZE__
	bne @l0

	rts
.endproc

;*******************************************************************************
; LINK DEBUG
; Links the given object files into a .D (debug) file of the given name
; IN:
;  .XY:   the output filename of the .D (debug) file
;  r0:    the number of .O files
;  r1/r2: address of array of .O filenames (as 0-terminated strings)
.export __link_debug
.proc __link_debug
.endproc

;*******************************************************************************
; LINK PRG
; Links the given object files into a .PRG file of the given name
; IN:
;  .XY:   the output filename of the .PRG (PRG) file
;  r0:    the number of .O files
;  r1/r2: the array of .O filenames (as 0-terminated strings)
.export __link_prg
.proc __link_prg
.endproc

;*******************************************************************************
; PARSE LINK FILE
; Parses the given linker config file into sections and segments, loading
; those into the linker's own section and segment state.
; The file must follow the format:
;
; ```
; MEMORY [
; SECTIONA:
;  start=$0000
;  end=$1000
; SECTIONB:
;  ...
; ]
; SEGMENTS [
;  SEGA: load = SECTIONA
;  run = SECTIONB
;  type = [BSS, RO, RW]
; ]
; ```
;
; IN:
;  - .XY: pointer to the link filename
;  - .A:  length of the filename
; OUT:
;  - .C: set if the file could not be successfully opened or parsed
.export __link_parse
.proc __link_parse
@filebuff=mem::spare
@filebuff_end=mem::spareend
@segments_declared=r8
@sections_declared=r9
	; setup the load address
	pha
	lda #<@filebuff
	sta file::loadaddr
	lda #>@filebuff
	sta file::loadaddr+1
	lda #<@filebuff_end
	sta file::load_address_end
	lda #>@filebuff_end
	sta file::load_address_end+1
	pla

	; load link file into filebuff
	CALL FINAL_BANK_MAIN, file::open_r
	CALL FINAL_BANK_MAIN, file::loadbin
	bcs @err

	ldxy #@filebuff
	stxy zp::line

	lda #$00
	sta @sections_declared
	sta @segments_declared

@getblock:
	; have all required blocks been declared?
	lda @sections_declared
	and @segments_declared
	beq @read_block

	; done, make sure rest of file is whitespace
:	ldy #$00
	lda (zp::line),y
	jsr is_ws
	bne @unexpected_char
	incw zp::line
	ldxy zp::line
	cmpw file::loadaddr
	bne :-
@done:	RETURN_OK

@read_block:
	; look for MEMORY or SEGMENTS definition
	jsr process_ws
	ldy #$00

	; is line "MEMORY"?
	ldxy #@memory
	jsr cmpline
	beq @parse_sections

	; else is line "SEGMENTS"?
	ldxy #@segments
	jsr cmpline
	beq @parse_segments

	; invalid string
	sec
@err:	rts

@parse_sections:
	; make sure we haven't already declared sections
	lda @sections_declared
	beq :+
	sec
	rts			; err, sections already declared

:	; read past "MEMORY" declaration
	CALL FINAL_BANK_MAIN, line::process_word
	inc @sections_declared

	; look for the '['
	jsr @get_open_brace
	beq :+
@unexpected_char:
	RETURN_ERR ERR_UNEXPECTED_CHAR

	; read the section into the section definitions table
:	incw zp::line		; move beyond the '['
	jsr process_ws
@l0:	jsr parse_section
	bcs @err		; -> rts
	inc numsections		; SECTION was successfully parsed

	jsr @get_closing_brace
	bne @l0			; if not ']', read next section
	incw zp::line		; else, move over the ']'
	bne @getblock		; and get the next block (SEGMENTS)

@parse_segments:
	; make sure SEGMENTS weren't already declared
	lda @segments_declared
	beq :+
	sec
	rts			; err, sections already declared

:	; read past "SEGMENTS"
	CALL FINAL_BANK_MAIN, line::process_word
	inc @segments_declared

	; look for the '['
	jsr @get_open_brace
	beq :+
	RETURN_ERR ERR_UNEXPECTED_CHAR

	; read the section into the section definitions table
:	incw zp::line		; move beyond the '['
	jsr process_ws
@l1:	jsr parse_segment
	bcs @err		; -> rts
	inc numsegments		; SEGMENT was successfully parsed
	jsr @get_closing_brace
	bne @l1			; if not ']', read next segment
	incw zp::line		; else, move over the ']'
	jmp @getblock		; and get next block (SECTIONS)

; return .Z set if first non-whitespace char is a '['
@get_open_brace:
	jsr process_ws
	ldy #$00
	lda (zp::line),y
	cmp #'['
	rts

; return .Z set if first non-whitespace char is a ']'
@get_closing_brace:
	jsr process_ws
	ldy #$00
	lda (zp::line),y
	cmp #']'
	rts

@memory:   .byte "memory",0
@segments: .byte "segments",0
.endproc

;*******************************************************************************
; PARSE SECTION
; Parses the definition for one SECTION in the MEMORY block of the linker file
; A section is defined by the section name followed by a ':'
; Followed by lines defining its start and end address
;
; SECTIONA:
;  start=$0000
;  end=$1000
;  fill=1
;
; IN:
;  - zp::line: points to the buffer to parse the SECTION from
; OUT:
;  - .C: set if section could not be parsed
.proc parse_section
@name=r0
@val=r2
@cnt=r4
@keybuff=$100
	; get address to store new section name to
	lda numsections
	asl			; *2
	asl			; *4
	asl			; *8
	adc #<section_names
	sta @name
	lda #>section_names
	adc #$00
	sta @name+1

	; read the section name (string terminated by ':')
	jsr process_ws
	ldy #$00
@l0:	lda (zp::line),y
	bne :+
@err:   RETURN_ERR ERR_UNEXPECTED_CHAR	; line ended without ':'
:	jsr is_newl
	beq @err
	cmp #':'
	beq @cont			; found end of section name
	sta (@name),y
	iny
	cpy #$08
	bcc @l0
	RETURN_ERR ERR_LABEL_TOO_LONG	; section name > 8 chars

@cont:	tya
	;sec			; +1 (move pointer after the ':')
	adc zp::line
	sta zp::line
	bcc @getprops
	inc zp::line+1

; read all properties defined for the SECTION
@getprops:
	jsr process_ws		; move the key name in section

	ldy #$00
	lda (zp::line),y
	cmp #';'		; are we at the end of the section?
	bne :+
	incw zp::line		; move beyond the semicolon
	RETURN_OK		; we're at the end, return

:	; read the key of the k/v pair into keybuffer
	ldxy #@keybuff
	jsr readkey
	bcs @err

@keyfound:
	ldxy #@keybuff
	stxy zp::str0

	; find the key that corresponds to the one in the config file
	ldxy #@keys
	stxy zp::str2

	lda #$00
	sta @cnt
@findkey:
	jsr strcmp
	bne @next

@found: ; found the key, run the command to map it
	ldx @cnt
	lda @cmdslo,x
	sta zp::jmpvec
	lda @cmdshi,x
	sta zp::jmpvec+1

	; evaluate the value for the handler
	jsr parse_val
	bcs @ret	; error -> rts

	; run the handler for the given key
	jsr zp::jmpaddr
	jmp @getprops	; repeat (get next key if there is one)

@next:	; move zp::str2 to the next key to check
	ldy #$00
:	lda (zp::str2),y
	incw zp::str2
	cmp #$00
	bne :-

	; are we out of keys?
	inc @cnt
	lda @cnt
	cmp #@numkeys
	bne @findkey

	; sec (unknown key)
@ret:	rts

;--------------------------------------
; handler for the "start" key in config file
@startvec:
	; set the start address for the segment
	txa
	ldx numsections
	sta sections_startlo,x
	tya
	sta sections_starthi,x
	rts

;--------------------------------------
; handler for the "stop" key in config file
@endvec:
	; set the end address for the segment
	txa
	ldx numsections
	sta sections_stoplo,x
	tya
	sta sections_stophi,x
	rts

;--------------------------------------
; handler for the "fill" key in config file
@fillvec:
	ldx numsections
	lda #SECTION_FILL
	sta sections_flags,x
	rts

;--------------------------------------
; keys table
@keys:
@numkeys=3
@start:	.byte "start",0
@end:	.byte "end",0
@fill:	.byte "fill",0

;--------------------------------------
; keys table handler vectors
.define sec_cmds @startvec, @endvec, @fillvec
@cmdslo: .lobytes sec_cmds
@cmdshi: .hibytes sec_cmds

.endproc

;*******************************************************************************
; PARSE SEGMENT
; Parses the definition for one SEGMENT in the SEGMENTS block of the linker file
; A segment is defined by the section name followed by a ':'
; Followed by lines defining its load and run addresses
; SEGA:
;  load=$0000
;  run=$1000
; IN:
;  - zp::line: points to the buffer to parse the SEGMENT from
; OUT:
;  - .C: set if the segment could not be parsed
.proc parse_segment
@name=r0
@val=r2
@cnt=r4
@keybuff=$100
@sec=$100
	; get address to store new segment name to
	lda numsegments
	asl			; *2
	asl			; *4
	asl			; *8
	adc #<segment_names
	sta @name
	lda #>segment_names
	adc #$00
	sta @name+1

	; read the segment name (string terminated by ':')
	jsr process_ws
	ldy #$00
@l0:	lda (zp::line),y
	bne :+
@err:   RETURN_ERR ERR_UNEXPECTED_CHAR	; line ended without ':'
:	jsr is_newl
	beq @err
	cmp #':'
	beq @cont			; found end of section name
	sta (@name),y
	iny
	cpy #$08
	bcc @l0
	RETURN_ERR ERR_LABEL_TOO_LONG	; section name > 8 chars

@cont:	tya
	;sec			; +1 (move pointer after the ':')
	adc zp::line
	sta zp::line
	bcc @getprops
	inc zp::line+1

; read all properties defined for the SEGMENT
@getprops:
	jsr process_ws		; move the key name in segment

	ldy #$00
	lda (zp::line),y
	cmp #';'		; are we at the end of the segment?
	bne :+
	incw zp::line		; move beyond the semicolon
	RETURN_OK		; we're at the end, return

:	; read the key of the k/v pair into keybuffer
	ldxy #@keybuff
	jsr readkey
	bcs @err

@keyfound:
	ldxy #@keybuff
	stxy zp::str0

	; find the key that corresponds to the one in the config file
	ldxy #@keys
	stxy zp::str2

	lda #$00
	sta @cnt
@findkey:
	jsr strcmp
	bne @next

@found: ; found the key, run the command to map it
	ldx @cnt
	lda @cmdslo,x
	sta zp::jmpvec
	lda @cmdshi,x
	sta zp::jmpvec+1

	; get the section ID from the value (string)
	; first, read the section name into a temp buffer
	ldy #$00
:	lda (zp::line),y
	beq @get_section
	cmp #';'
	beq @get_section
	jsr is_ws
	beq @get_section
	sta @sec,y
	iny
	bne :-

@get_section:
	lda #$00
	sta @sec,y	; terminate the section name buffer

	; update line pointer to after the name that was read
	tya
	clc
	adc zp::line
	sta zp::line
	bcc :+
	inc zp::line+1

:	; get the section ID
	ldxy #@sec
	jsr get_section_by_name
	bcs @ret		; section not found -> rts

	; .A = .XY = section ID
	tax
	ldy #$00

	; run the handler for the given key
	jsr zp::jmpaddr
	jmp @getprops	; repeat (get next key if there is one)

@next:	; move zp::str2 to the next key to check
	ldy #$00
:	lda (zp::str2),y
	incw zp::str2
	cmp #$00
	bne :-

	; are we out of keys?
	inc @cnt
	lda @cnt
	cmp #@numkeys
	bne @findkey

	; sec (unknown key)
@ret:	rts

;--------------------------------------
; handler for the "run" key in SEGMENT
@runvec:
	; set the run section for the segment
	ldx numsegments
	sta segments_load,x
	rts

;--------------------------------------
; handler for the "load" key in SEGMENT
@loadvec:
	; set the load section for the segment
	ldx numsegments
	sta segments_run,x
	rts

;--------------------------------------
; keys table
@numkeys=2
@keys:
@load:     .byte "load",0
@run:      .byte "run",0

;--------------------------------------
; keys table handler vectors
.define seg_cmds @runvec, @loadvec
@cmdslo: .lobytes seg_cmds
@cmdshi: .hibytes seg_cmds

.endproc

;*******************************************************************************
; FILE ID FROM SCOPE
; Parses the object file ID (index in objfiles) from the given symbol's scope.
; E.g. "FOO:LABEL" will return the index for the file "FOO"
; IN:
;   - .XA: the symbol to match
; OUT:
;   - .A: the file ID for the symbol (from its scope)
.proc file_id_from_scope
@sym=zp::str0
@objs=zp::str1
@i=r0
	stx @sym
	sta @sym+1

	ldxy #__link_objfiles
	stxy @objs

	; get the length of the namespace to search for
	ldy #$00
	sty @i			; init index

@l0:	lda (@sym),y
	cmp #':'		; scope separator
	beq @find
	iny
	bne @l0

@find:	jsr strcmp		; search
	beq @done		; if match -> we're done

	; move @obj pointer to next filename
	ldy #$00
@l1:	lda (@objs),y
	beq @next
	iny
	bne @l1			; branch always

@next:	inc @i			; increment id counter
	tya
	sec			; +1 (move OVER the terminator)
	adc @objs
	sta @objs
	bcc @l1
	inc @objs+1
	bne @l1

@done:	lda @i
	rts
.endproc

;*******************************************************************************
; GET FILE SECTION TABLE
; Returns the section offset table for the given symbol by parsing and
; using ts namespace
; IN:
;   - .XA: the symbol to return the table for
; OUT
;   - .XY: the table of section offsets for the given symbol's file
.proc get_file_section_table
	jsr file_id_from_scope
	asl				; *16
	asl
	asl
	asl
	adc #<file_segments_startlo
	tax
	adc #>file_segments_startlo
	tay
	rts
.endproc

;*******************************************************************************
; RESOLVE GLOBALS
; Calculates the addresses for each global that was extracted from the object
; file headers in the linker's first pass
.proc resolve_globals
@i=zp::tmp10
@sec_id=zp::tmp12
@obj_sec_offsets=zp::tmp14
@namebuff=$100
	iszero lbl::num
	bne :+
	RETURN_OK				; no globals

:	; iterate through all labels
	ldxy #0
	stx @i
	stx @i+1

@l0:	; get the address of the section table for file containing the symbol
	CALL FINAL_BANK_MAIN, lbl::name_by_id	; look up the label's name
	jsr get_file_section_table		; get offset table for file
	stxy @obj_sec_offsets			; save the object table pointer

	; look up the section ID for the symbol
	ldxy @i
	CALL FINAL_BANK_MAIN, lbl::getsection	; get section ID
	cmp #SEC_ABS				; is section ABSOLUTE?
	beq @next				; if so, already resolved
	cmp #SEC_UNDEF				; is section UNDEFINED?
	beq @err				; if so, error
	sta @sec_id				; save section ID

	; look up the section-offset (address) for the symbol
	ldxy @i
	CALL FINAL_BANK_MAIN, lbl::by_id	; look up the symbol's offset
	tya
	pha					; save MSB
	clc
	txa
	ldy @sec_id				; restore section ID
	adc (@obj_sec_offsets),y		; add file offset to resolve
	sta zp::label_value
	pla					; restore MSB
	iny
	adc (@obj_sec_offsets),y
	sta zp::label_value+1

	; store the resolved address
	ldxy @i					; restore symbol ID to update
	CALL FINAL_BANK_MAIN, lbl::setaddr	; store the resolved address

@next:	incw @i
	ldxy @i
	cmpw lbl::num
	beq @done
	jmp @l0					; repeat for all globals

@done:	RETURN_OK

@err:	;sec
	lda #ERR_LABEL_UNDEFINED
	rts
.endproc

;*******************************************************************************
; LINK
; Links all files that were added to the linker (link::addfile) and produces
; the linked executable as a file with the given name.
; IN:
;  - .XY:            the filename to produce from the linked files
;  - .A:             the number of input files
;  - link::objfiles: array of the files to link
; OUT:
;  - .C: set on error
.export __link_link
.proc __link_link
@outfile=zp::link
@objfile=zp::link+2	; pointer to current object file being linked
@i=zp::link+4
@segname=zp::line+6
@obj_id=zp::line+8
	stxy @outfile

	; init the segment/section pointers using the current linker state
	; (parsed from the LINK file prior to calling this procedured)
	ldx numsegments
	bne @initsegments

	sec		; no segments defined; return error
@ret:	rts

@initsegments:
	; set the start address for each SECTION to the SEGMENT
	; load address parsed from the LINK file
	dex
@l0:	ldy segments_load,x
	lda sections_startlo,y
	sta segments_addrlo,x
	lda sections_starthi,y
	sta segments_addrhi,x
	dex
	bpl @l0

	; init obj pointer to start of object list
	ldxy #__link_objfiles
	stxy @objfile

@pass1: ; pass 1:
	; Extract header data foreach file and update pointers to each file
	; to the main block of the .O file
	; Also define labels for the globals (IMPORT/EXPORT blocks) defined
	; in each object file

	; load the next .O (object) file in the object list
	ldxy @objfile
	stxy obj::filename
	CALL FINAL_BANK_MAIN, file::open_r
	bcs @ret
	tax
	jsr $ffc6		; CHKIN
	jsr obj::load_headers	; get section sizes and add global labels
	bcs @ret

	; store the current base addresses for each SEGMENT for the object file
	ldx numsegments
:	lda segments_addrlo-1,x
	adc segments_sizelo-1,x
	sta file_segments_startlo-1,x
	lda segments_addrhi-1,x
	adc segments_sizehi-1,x
	sta file_segments_starthi-1,x
	dex
	bpl :-

@calc_segment_sizes:
	; get the new size of each SEGMENT by adding the number of bytes
	; used in the object file for that SEGMENT
	ldxy #obj::segments
	stxy @segname
	lda #$00
	sta @i
	cmp obj::numsegments
	beq @nextfile			; if no sections used, continue

	; get the id of the segment by its name
	ldxy @segname			; address of segment name
	jsr get_segment_by_name		; get its ID
	tax				; .X=segment index (global context)
	ldy @i				; .Y=segment index (object file)

	; update the size of the segment: segment_size += section_size
	lda obj::segments_sizelo,y
	clc
	adc segments_sizelo,x
	sta segments_sizelo,x
	lda obj::segments_sizehi,y
	adc segments_sizehi,x
	sta segments_sizehi,x

	; move to next segment name
	lda @segname
	clc
	adc #MAX_SEGMENT_NAME_LEN
	sta @segname
	bcc :+
	inc @segname+1
:	inc @i				; next SEGMENT
	cmp obj::numsections		; are we done?
	bne @calc_segment_sizes		; repeat for all SEGMENTS in file

@nextfile:
	; next ile; update filename pointer to next filename
	ldy #$01		; start search at 2nd character of filename
:	lda (@objfile),y	; get a char
	beq :+			; if 0, we've found terminator -> continue
	iny			; next char
	bne :-			; repeat til we've found 0

:	tya
	clc
	adc @objfile
	sta @objfile
	bcc :+
	inc @objfile+1
:	ldy #$01
	lda (@objfile),y	; get char after the terminating 0
	beq @pass1done		; if it's another 0, we're at end of obj list
	jmp @l0			; if not, repeat for next obj file

@pass1done:
	; resolve symbols now that we know the base address of each SEGMENT
	; in each object file
	jsr resolve_globals

@validate:
	; make sure SEGMENT base+size is less than the top of the SEGMENT
	; TODO:
	; RETURN_ERR ERR_SECTION_TOO_SMALL

@start_pass2:
	; reset obj pointer to start of object list
	ldxy #__link_objfiles
	stxy @objfile

@objects:
	; iterate over each object file and link it
	ldxy @objfile
	jsr link_object		; link the object file
	bcs @done		; if .C set, return with error

	; update filename pointer to next filename
	ldy #$01
:	lda (@objfile),y
	beq :+
	iny
	bne :-

:	tya
	clc
	adc @objfile
	sta @objfile
	bcc :+
	inc @objfile+1
:	ldy #$01
	lda (@objfile),y	; are there more files? (next file is !0)
	bne @objects		; if so, repeat
	clc			; all objects linked, return success
@done:	rts
.endproc

;*******************************************************************************
; LINK OBJECT
; Produces the final binary for a given object file
; IN:
;   - .XY: address of the object filename to link
.proc link_object
@sec_idx=zp::tmp10
	CALL FINAL_BANK_MAIN, file::open_r
	tax
	jsr $ffc6		; CHKIN
	jsr obj::load		; load the object file with the given index
	bcs @ret

	; iterate over each section and link it: apply relocation, and produce
	; debug info

@reloc:	; walk the relocation table and apply all relocations
	lda @sec_idx
	jsr obj::apply_relocation
	bcc @reloc

@dbgi:	; write the debug information
	; TODO:

	inc @sec_idx		; next section
	lda @sec_idx
	cmp obj::numsections
	bne @reloc		; repeat for all sections

@done:	clc
@ret:	rts
.endproc

;******************************************************************************
; SET SEG
; Sets the segment to the given segment name
; e.g.
;  SEG "DATA"
; The binary representatino is similar
;  $03 "DATA",0
; Where $03 is the binary opcode for "SEG" and "DATA" is still the literal
; segment data (0-terminated)
; IN:
;  - objptr: the current pointer in the object code
.proc set_seg
	; update the current end address of the active segment
	ldx activeseg
	lda segptr
	sta segments_addrlo,x
	lda segptr+1
	sta segments_addrhi,x

	; get the operand (SEGMENT id)
	ldxy objptr
	jsr get_segment_by_name
	bcs @done		; return error if not found
	sta activeseg
	tax
	lda segments_addrlo,x
	sta segptr
	lda segments_addrhi,x
	sta segptr+1

	; move past the name
	ldy #$ff
:	iny
	lda (objptr),y
	bne :-

	tya
	sec			; +1 (get past the 0)
	adc objptr
	bcc @done
	inc objptr+1
@done:	rts
.endproc

;*******************************************************************************
; EXTRACT HEADERS
; Extracts the header data from the .obj file and builds the absolute address
; of any EXPORTs for the .obj file. These are added as labels (lbl::add).
; Then updates the SEGMENT pointers by the sizes of each SEGMENT used in the
; .obj file.
;
; The first block contains the names of all segments used in the object file.
; This is a list of 0-terminated strings.
; ---------------------------------
; |  Property       | Size (bytes)|
; |-----------------|-------------|
; | Segment 0 Name  |  1-32       |
; | Segment 1 Name  |  1-32       |
; | end marker (0)  |  1          |
; ---------------------------------
;
; The next block contains the SYMBOL table for the block
; Exported symbols may be relative to a SEGMENT. To identify the SEGMENT
; they contain a 1 byte ID, which refers to their index in the segment
; table for the object file
;
; -----------------------------------------------
; |  Property                     | Size (bytes)|
; |-------------------------------|-------------|
; | Symbol 0 Name                 |  1-32       |
; | Symbol 0 Type                 |  1-32       |
; | (if export: Export 0 Segment) |    1        |
; | (if export: Export 0 Offset)  |    2        |
; | Symbol 1 Name                 |  1-32       |
; | Symbol 1 Type                 |  1-32       |
; | (if export: Export 1 Segment) |    1        |
; | (if export: Export 1 Offset)  |    2        |
; -----------------------------------------------
;
; The next block of headers tells the linker the name and size of each SEGMENT
; in the .obj file
; --------------------------------
; |  Property      | Size (bytes)|
; |----------------|-------------|
; | SEG1 name      |  16         |
; | sizeof(SEG1)   |  2          |
; | SEG2 name      |  16         |
; | sizeof(SEG2)   |  2          |
; | end marker (0) |  1          |
; --------------------------------
;
; IN:
;  - .XY: address to the contents of the .obj file
; OUT:
;  - .XY:             address of the remainder of the .obj file (after headers)
;  - segments_stoplo: updated with new LSBs of end of affected segments
;  - segments_stophi: updated with new MSBs of end of affected segments
;  - labels:          updated with any EXPORTed symbols from .obj file
.proc extract_headers
EXPORT_SEG  = 8 		; offset to SEGMENT name in IMPORT header
EXPORT_SIZE = 8+8		; offset to SIZE in IMPORT header
EXPORT_BLOCK_ITEM_SIZE = 8 + EXPORT_SEG + EXPORT_SIZE
@fptr=r0
@segaddr=r2
@buff=r4
	stxy @fptr
	ldx numfiles
@getsegments:

@getsymbols:
	; get the absolute address of the segment
	lda #EXPORT_SEG
	clc
	adc @buff
	tax
	lda @buff+1
	adc #$00
	tay
	jsr get_segment_by_name
	stxy @segaddr

	; calclulate the absolute address for the EXPORT
	ldy #EXPORT_SIZE
	lda (@buff),y
	clc
	adc @segaddr
	sta zp::label_value
	iny
	lda (@buff),y
	adc @segaddr+1
	sta zp::label_value+1

	ldxy #@buff	; name of the EXPORT
	jsr lbl::add	; add the EXPORT to the symbol table

	; move fptr to next EXPORT or block
	lda @fptr
	clc
	adc #EXPORT_BLOCK_ITEM_SIZE
	sta @fptr
	bcc :+
	inc @fptr
:	ldy #$00
	lda (@fptr),y
	bne @getsymbols ; if not end of block, continue
	incw @fptr	; move past terminating 0

; sum the SEGMENT sizes for the header with our existing sizes for those
; segments and set the STOP addresses accordingly
@updatesegments:
	ldxy #@fptr		; SEGMENT name
	jsr get_segment_by_name
	tax
	ldy #8			; offset to SIZE
	lda (@fptr),y
	clc
	adc segments_sizelo,x
	sta segments_sizelo,x
	iny
	lda (@fptr),y
	adc segments_sizehi,x
	sta segments_sizehi,x

	lda @fptr
	adc #10			; sizeof(NAME) + sizeof(SIZE)
	sta @fptr
	bcc :+
	inc @fptr+1
:	ldy #$00
	lda (@fptr),y
	bne @updatesegments	; loop if not end of SEGMENT block

	incw @fptr
	ldxy @fptr
	rts
.endproc

;*******************************************************************************
; GEN SEGMENT MAP
; Read the IMPORT block from the open OBJECT file and
.proc gen_segment_map
.endproc

;******************************************************************************
; GET SECTION BY NAME
; Returns the ID of the section from its name
; IN:
;  - .XY: the name of the section
; OUT:
;  - .A: the ID of the section
;  - .C: set if no segment exists by the given name
.proc get_section_by_name
@name=zp::str0
@other=zp::str2
@cnt=r0
	stxy @name
	ldxy #section_names
	stxy @other

	lda #$00
	sta @cnt
@l0:	lda #$08
	jsr strcmp
	beq @found
	lda @other
	clc
	adc #$08
	sta @other
	ldx @cnt
	inx
	stx @cnt
	cpx numsections
	bcc @l0
@notfound:
	rts

@found: lda @cnt
	RETURN_OK
.endproc

;******************************************************************************
; GET SEGMENT BY NAME
; Returns the ID of the segment from its name
; IN:
;  - .XY: the name of the segment
; OUT:
;  - .A: the ID of the segment
;  - .C: set if no segment exists by the given name
.export __link_get_segment_by_name
__link_get_segment_by_name:
.proc get_segment_by_name
@name=zp::str0
@other=zp::str2
@cnt=r0
	stxy @name
	ldxy #segment_names
	stxy @other

	lda #$00
	sta @cnt
@l0:	lda #$08
	jsr strcmp
	beq @found
	lda @other
	clc
	adc #$08
	sta @other
	ldx @cnt
	inx
	stx @cnt
	cpx numsegments
	bcc @l0
@notfound:
	rts

@found: lda @cnt
	RETURN_OK
.endproc

;*******************************************************************************
; READ KEY
; Read the key in a key/value pair into the given buffer
; A key/value pair is a string and value separated by an '=' sign
; IN:
;   - zp::line: the buffer to read the key from
;   - .XY:      the address to read the key into
; OUT:
;   - zp::line: updated to point after the '=' in the key/value pair
;   - .C:       set if the input buffer is not a valid key/value pair
.proc readkey
@buff=r0
	stxy @buff

	ldy #$00
@l0:	lda (zp::line),y
	jsr is_newl
	beq @err	; unexpected newline
	cmp #'='
	beq @done	; found end of key definition
	sta (@buff),y
	iny
	cpy #8
	bcc @l0
	RETURN_ERR ERR_LABEL_TOO_LONG

@done:	lda #$00
	sta (@buff),y	; terminate bufffer
	tya
	sec		; +1
	adc zp::line
	sta zp::line
	bcc :+
	inc zp::line+1
:	RETURN_OK

@err:	RETURN_ERR ERR_UNEXPECTED_CHAR
.endproc

;*******************************************************************************
; PARSE VAL
; Parses the value from the key/value pair
; e.g. A=120
; IN:
;   - zp::line: points to the value of a key/value pair
; OUT:
;   - zp::line: points after the value in the buffer
;   - .XY:      the value of the key/value pair
;   - .C:       set if the key/value pair was not parsed successfully
.proc parse_val
@val=r0
@buff=$100
	jsr process_ws

	; read the value into a temporary buffer
@l0:	lda (zp::line),y
	beq :+
	jsr is_newl
	beq :+
	cmp #';'	; SEGMENT/SECTION terminator
	beq :+
	sta @buff,y
	iny
	bne @l0

:	lda #$00
	sta @buff,y
	tay

	; check if the value is hex or decimal
	lda (zp::line),y
	cmp #'$'
	beq @hex

@dec:	ldxy #@buff
	CALL FINAL_BANK_MAIN, atoi
	bcc @cont
	rts			; error

@hex:	; get the value of the value string
	ldxy #@buff+1		; +1 to get after the '$'
	CALL FINAL_BANK_MAIN, util::parsehex
	bcs @ret

@cont:	stxy @val
	; move beyond the value string (to start of next word or ';')
	ldy #$00
:	lda (zp::line),y
	jsr is_newl
	beq @done
	cmp #';'
	beq @done
	iny
	jsr is_ws
	bne :-

@done:	tya
	clc
	adc zp::line
	sta zp::line
	bcc :+
	inc zp::line+1
:	ldxy @val
	clc		; ok
@ret:	rts
.endproc

;*******************************************************************************
; COMPARE LINE
; Compares the strings in (zp::line) and (.XY) up to a length of .A
.proc cmpline
	stxy zp::str2
	ldxy zp::line
	stxy zp::str0

	; fall through to strcmp
.endproc

;*******************************************************************************
; COMPARE
; Compares the strings in (zp::str0) and (zp::str2) up to a length of .A
; IN:
;  zp::str0: one of the strings to compare
;  zp::str2: the other string to compare
; OUT:
;  .Z: set if the strings are equal
.proc strcmp
	ldy #$00
@l0:	lda (zp::str0),y
	beq :+
	jsr is_ws
	beq :+
	cmp (zp::str2),y
	bne @ret
	iny
	bne @l0

:	lda (zp::str2),y	; make sure strings terminate at same index
@ret:	rts
.endproc

;*******************************************************************************
; PROCESS WS
; Reads (line) and updates it to point past ' ' chars and non-printing chars
; out:
;  .Z: set if we're at the end of the line
;  .A: the last character processed
;  .Y: 0
;  zp::line: updated to first non ' ' character
.proc process_ws
	ldy #$00
@l0:	lda (zp::line),y
	beq @done		; if end of line, we're done
	bmi @skip		; skip non-printing chars
	jsr is_ws
	bne @done		; if not space, we're done
@skip:	incw zp::line
	bne @l0
@done:	rts
.endproc

;*******************************************************************************
; IS NEWL
; Checks if the given character is a newline ($0d or $0a)
; IN:
;  - .A: the character to test
; OUT:
;  - .Z: set if if the character in .A is whitespace
.proc is_newl
	cmp #$0d	; newline
	beq :+
	cmp #$0a	; UNIX newline
:	rts
.endproc

;*******************************************************************************
; IS WS
; Checks if the given character is a whitespace character
; IN:
;  - .A: the character to test
; OUT:
;  - .Z: set if if the character in .A is whitespace
.proc is_ws
	cmp #$0d	; newline
	beq :+
	cmp #$09	; TAB
	beq :+
	cmp #$0a	; UNIX newline
	beq :+
	cmp #' '
:	rts
.endproc

;*******************************************************************************
; IS NULL SPACE COMMA CLOSINGPAREN
; IN:
;  - .A: the character to test
; OUT:
;  - .Z: set if the char in .A is: 0,$0d,' ', ',', or ')'
.proc is_null_return_space_comma_closingparen_newline
	cmp #$00
	beq @done
	jsr is_ws
	beq @done
	cmp #','
	beq @done
	cmp #')'
@done:	rts
.endproc

;*******************************************************************************
; IS OPERATOR
; IN:
;  - .A: the character to test
; OUT:
;  - .Z: set if the char in .A is an operator ('+', '-', etc.)
.proc isoperator
@xsave=zp::util+2
	stx @xsave
	ldx #@numops-1
:	cmp @ops,x
	beq @end
	dex
	bpl :-
@end:	php
	ldx @xsave
	plp
	rts
@ops: 	.byte '(', ')', '+', '-', '*', '/', '[', ']', '^', '&', '.'
@numops = *-@ops
.endproc

;*******************************************************************************
; ISSEPARATOR
; IN:
;  - .A: the character to test
; OUT:
;  - .Z: set if the char in .A is any separator
.proc isseparator
	cmp #':'
	beq @yes
	jsr is_null_return_space_comma_closingparen_newline
	bne :+
@yes:	rts
:	jmp isoperator
.endproc
