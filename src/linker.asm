;*******************************************************************************
; LINKER.ASM
; The linker links the object code generated by the assembler into a binary
; (.prg or plain) or debug (.d) file.
;
; See the OBJECT CODE overview below for details on the object format.
;*******************************************************************************

.include "errors.inc"
.include "file.inc"
.include "labels.inc"
.include "line.inc"
.include "macros.inc"
.include "memory.inc"
.include "string.inc"
.include "strings.inc"
.include "util.inc"
.include "zeropage.inc"

.include "vic20/finalex.inc"

;*******************************************************************************
; CONSTANTS
MAX_SECTIONS         = 8	; max number of memory sections
MAX_SEGMENTS         = 8	; max number of segments across all objects
MAX_OBJS             = 16	; max number of object files that may be used
MAX_SECTION_NAME_LEN = 8	; max length of a single section name

;*******************************************************************************
; SECTION flags
SECTION_FILL = $01	; flag to pad section's unused bytes with 0

;*******************************************************************************
; SEGMENT flags
SEGMENT_RO     = $01	; RO (readonly) writes to segment will be error
SEGMENT_DEFINE = $02

;*******************************************************************************
; ZEROPAGE variables
; OBJPTR is the cursor in the object code (where we are reading in the current
; object file)
; SEGPTR is the cursor to the .PRG or .D file (where we are WRITIING)
objptr=zp::link
segptr=zp::link+2

;*******************************************************************************
.BSS

numobjects:  .byte 0
numsegments: .byte 0
numsections: .byte 0
numfiles:    .byte 0

activeobj: .byte 0	; the current OBJECT (id) being linked
activeseg: .byte 0	; the current SEGMENT (id) being written

;*******************************************************************************
; SECTIONS
; The memory section contains up to MAX_SECTIONS of memory blocks.  Each
; defines the start and end addresses of the section plus a byte of flag
; data, which is used to, for example, flag that the section should be padded
; if the SEGMENTs that map to this section do not span the entire
; [start, stop] address space.
; The format of a SECTION is:
;  .word start addr
;  .word stop addr
;  .byte flags
sections_startlo: .res MAX_SECTIONS
sections_starthi: .res MAX_SECTIONS
sections_stoplo:  .res MAX_SECTIONS
sections_stophi:  .res MAX_SECTIONS
sections_flags:   .res MAX_SECTIONS
section_names:    .res MAX_SECTIONS*MAX_SECTION_NAME_LEN

;*******************************************************************************
; IMPORT TABLES
; Each object file has its own table of imports. This allows the object code to
; store refrences to external labels in a more efficient manner: by storing the
; index to the label in the IMPORT table instead of the label itself.
import_tabslo: .res MAX_OBJS
import_tabshi: .res MAX_OBJS

;*******************************************************************************
; SEGMENTS
; Segments define where the code or data that occupies them will be mapped to
; the memory defined in the SECTIONS blocks
; SEGMENTs may LOAD to one address but RUN in another. Note the corresponding
; bytes in the SEGMENT structure that select this.
;
; SEGMENTs have the format:
;  .byte[8] name
;  .byte    LOAD SEGMENT id
;  .byte    RUN SEGMENT id
;  .byte    flags
segments_load:   .res MAX_SEGMENTS
segments_run:    .res MAX_SEGMENTS
segments_flags:  .res MAX_SEGMENTS
segments_sizelo: .res MAX_SEGMENTS
segments_sizehi: .res MAX_SEGMENTS

segments_startlo: .res MAX_SEGMENTS
segments_starthi: .res MAX_SEGMENTS
segments_stoplo:  .res MAX_SEGMENTS
segments_stophi:  .res MAX_SEGMENTS

segment_names: .res 8*MAX_SEGMENTS

;******************************************************************************
; OBJECT CODE overview
; Object code is stored in a simple block format as follows
;  - the 1st block contains all IMPORTs required to link the file
;  - the 2nd contains all EXPORTs exported by the file (and their offsets)
;  - the 3rd contains the SEGMENTs used and the # of bytes each uses
;  - the 4th contains the relocatable data
; Example:
;  IMP LAB1
;  IMP LAB2
;  EXP my_proc  CODE+$1000
;  EXP my_proc2 SETUP+$20
;
;  CODE $1032
;  DATA $0062
;
;  | Obj Code Def        | Description                               |
;  |-----------------------------------------------------------------|
;  | SEG CODE            | Switches to the CODE segment              |
;  | b $01 $33 $44       | defines bytes at CODE+0, CODE+1, CODE+2   |
;  | b $ad               | defines a byte at CODE+3                  |
;  | w LAB+3             | defines WORD with the value of LAB        |
;
; The value of segments (e.g. CODE) will change after each compilation unit
; is linked.
; After each file is linked, they are updated by the number of bytes produced
; for that segment by that unit.
; So if our unit has $200 bytes of code/data in its CODE segment, the
; hypothetical next unit will start assembling its CODE segment at CODE+$200
;
; Exports are calculated during linkage according to the current offset +
; SEGMENT values
;******************************************************************************

;******************************************************************************
; DEBUG FILE overview
; Debug (.d) files are binary files that contain the linked object code.
; They are similar to the object files that they are built from.
;
; To assist in debugging, they _also_ contain information like line numbers
; and files. The imports and exports tables are also replaced with a single
; "symbol" table.
;
; Debug files cannot be run outside the Monster environment. To produce a
; standalone .PRG use dbg::linkprg
;
; EXAMPLE:
;  FILE NAMES:
;   hello.s
;   main.s
;
;  NUM_SYMBOLS: 4
;
;  SYMBOLS:
;   LAB1     CODE+$1600  hello.s L:120
;   LAB2     CODE+$1402  hello.s L:40
;   my_proc  CODE+$1000  main.s  L:200
;   my_proc2 SETUP+$20   main.s  L:10
;
;  SEGMENTS:
;   CODE $1032
;   DATA $062
;******************************************************************************

;******************************************************************************
; OBJ Code Opcodes
; These represent the "instruction" opcodes of the object code
OBJ_SETSEG  = $01       ; switches to the given segment e.g. "SEG DATA"
OBJ_BYTES   = $02 	; RLE encoded byte values e.g. "B 4 0 1 2 3"
OBJ_RELBYTE = $03	; byte value + word offset "RB LAB+3"
OBJ_RELWORD = $04	; word value + word offset "RW LAB+10"
OBJ_RELZP   = $05	; byte value followed by relative byte "RZ $20 LAB+10"
OBJ_RELABS  = $06	; byte value followed by relative word "RA $20 LAB+5"

.segment "LINKER"
;*******************************************************************************
; LINK DEBUG
; Links the given object files into a .D (debug) file of the given name
; IN:
;  .XY:   the output filename of the .D (debug) file
;  r0:    the number of .O files
;  r1/r2: the array of .O filenames (as 0-terminated strings)
.export __link_debug
.proc __link_debug
.endproc

;*******************************************************************************
; LINK PRG
; Links the given object files into a .PRG file of the given name
; IN:
;  .XY:   the output filename of the .PRG (PRG) file
;  r0:    the number of .O files
;  r1/r2: the array of .O filenames (as 0-terminated strings)
.export __link_prg
.proc __link_prg
.endproc

;*******************************************************************************
; ADD SECTION
; Adds a new section using the given parameters
; IN:
;  - r0: the start address for the segment
;  - r2: the stop address for the segment
;  - .A:       flags for the segment
.export __link_add_section
.proc __link_add_section
@start=r0
@stop=r2
@flags=r4
	ldx numsections

	sta sections_flags,x

	lda @start
	sta sections_startlo,x
	lda @start+1
	sta sections_starthi,x

	lda @stop
	sta sections_stoplo,x
	lda @stop+1
	sta sections_stophi,x

	inc numsections
	rts
.endproc

;*******************************************************************************
; ADD SEGMENT
; Adds a new segment using the given parameters
; IN:
;  - r0:  pointer to the name for the segment
;  - .A:  LOAD section id
;  - .X:  RUN section id
;  - .Y:  flags
.export __link_add_segment
.proc __link_add_segment
@run=r0
	stx @run

	sta segments_load,x
	tya
	sta segments_flags,x
	lda @run
	sta segments_run,x

	inc numsegments
	rts
.endproc

;*******************************************************************************
; PARSE LINK FILE
; Parses the given file into sections and segments, loading those into the
; linker's own section and segment state.
; The file must follow the format:
;
; ```
; MEMORY [
; SECTIONA:
;  start=$0000
;  end=$1000
; SECTIONB:
;  ...
; ]
; SEGMENTS [
;  SEGA: load = SECTIONA, run = SECTIONB
; ]
; ```
;
; IN:
;  - .XY: pointer to the link filename
;  - .A:  length of the filename
; OUT:
;  - .C: set if the file could not be successfully opened or parsed
.export __link_parse
.proc __link_parse
@filebuff=mem::spare
@line=mem::linebuffer
	pha
	lda #<@filebuff
	sta file::loadaddr
	lda #>@filebuff
	sta file::loadaddr+1
	pla

	; load link file into filebuff
	CALL FINAL_BANK_MAIN, #file::open_r
	CALL FINAL_BANK_MAIN, #file::loadbin
	bcs @err

	ldxy #@filebuff
	stxy zp::line

@getblock:
	CALL FINAL_BANK_MAIN, #line::process_ws
	ldy #$00

	; is line "MEMORY"?
	ldxy #@memory
	lda #6
	jsr cmpline
	beq @parse_sections

	ldxy #@segments
	lda #8
	jsr cmpline
	beq @parse_segments

	; invalid string
	sec
@err:	rts

@parse_sections:
	jsr @get_open_brace
	bcs @err

	; read the section into the section definitions table
:	jsr parse_section
	bcs @err
	jsr @get_closing_brace
	bcc :-

	; make sure last character is a ']'
	cmp #']'
	beq :+
	sec		; error SECTION not closed
	rts

:	clc		; ok
	rts

@parse_segments:
	jsr @get_open_brace
	bcs @err

	; read the section into the section definitions table
:	jsr parse_segment
	bcs @err
	jsr @get_closing_brace
	bcc :-

	; make sure last character is a ']'
	cmp #']'
	beq :+
	sec		; error SEGMENT not closed
	rts

:	clc		; ok
	rts

@get_open_brace:
	; TODO:

@get_closing_brace:
	; TODO:

@memory:   .byte "memory",0
@segments: .byte "segments",0
.endproc

;*******************************************************************************
; PARSE SECTION
; Parses the definition for one SECTION in the MEMORY block of the linker file
; A section is defined by the section name followed by a ':'
; Followed by lines defining its start and end address
;
; SECTIONA:
;  start=$0000
;  end=$1000
;  fill=1
;
; IN:
;  - zp::line: points to the buffer to parse the SECTION from
.proc parse_section
@name=r0
@val=r2
@cnt=r4
@keybuff=r5
	; get address to store new section name to
	lda numsections
	asl			; *2
	asl			; *4
	asl			; *8
	adc #<section_names
	sta @name
	lda #>section_names
	adc #$00
	sta @name+1

	; read the section name
	ldy #$00
@l0:	lda (zp::line),y
	beq @err		; no ':' -> error
	cmp #':'
	beq @cont		; found end of section name
	sta (@name),y
	iny
	cpy #$08
	bcc @l0
@err:	rts

@cont:	tya
	;sec			; +1 (move passed ':')
	adc zp::line
	sta zp::line
	bcc :+
	inc zp::line
:	jsr process_ws

; read all properties defined for the SECTION
@getprops:
	ldxy @keybuff
	jsr parse_kv
	stxy @val

	ldxy @keybuff
	stxy zp::str0

	; find the key that corresponds to the one in the config file
	ldxy #@keys
	stxy zp::str2

	lda #$00
	sta @cnt
@findkey:
	lda #6
	jsr strcmp
	bne @next

@found: ; found the key, run the command to map it
	ldx @cnt
	lda @cmdslo,x
	sta zp::jmpvec
	lda @cmdshi,x
	sta zp::jmpvec
	jsr zp::jmpaddr
	jmp @getprops	; repeat (get next key if there is one)

@next:	ldy #$00
	; move zp::str2 to the next key to check
:	incw zp::str2
	lda (zp::str2),y
	bne :-

	; are we out of keys?
	inc @cnt
	lda @cnt
	cmp #@numkeys
	bne @findkey

;--------------------------------------
; handler for the "start" key in config file
@startvec:
	; set the start address for the segment
	ldx numsections
	lda @val
	sta segments_startlo,x
	lda @val+1
	sta segments_starthi,x
	rts

;--------------------------------------
; handler for the "stop" key in config file
@endvec:
	; set the end address for the segment
	ldx numsections
	lda @val
	sta segments_stoplo,x
	lda @val+1
	sta segments_stophi,x
	rts

;--------------------------------------
; handler for the "fill" key in config file
@fillvec:
	ldx numsections
	lda #SECTION_FILL
	sta sections_flags,x
	rts

;--------------------------------------
; keys table
@keys:
@numkeys=3
@start:	.byte "start",0
@end:	.byte "end",0
@fill:	.byte "fill",0

;--------------------------------------
; keys table handler vectors
.define cmds @startvec, @endvec, @fillvec
@cmdslo: .lobytes cmds
@cmdshi: .hibytes cmds

.endproc

;*******************************************************************************
; PARSE SEGMENT
; Parses the definition for one SEGMENT in the SEGMENTS block of the linker file
; A segment is defined by the section name followed by a ':'
; Followed by lines defining its load and run addresses
; SEGA:
;  load=$0000
;  run=$1000
; IN:
;  - zp::line: points to the buffer to parse the SEGMENT from
.proc parse_segment
@load:     .byte "load",0
@run:      .byte "run",0
.endproc

;*******************************************************************************
; LINK
; Links all files that were added to the linker (link::addfile) and produces
; the linked executable as a file with the given name.
; IN:
;  - .XY:            the filename to produce from the linked files
;  - .A:             the number of input files
;  - link::objfiles: array of the files to link
; OUT:
;  - .C: set on error
.proc __link_link
@segptrs=r0		; 2*MAX_SEGMENTS bytes
@secptrs=zp::tmp10 	; 2*MAX_SECTIONS bytes
@filename=zp::link
	stxy @filename
	; init the segment/section pointers using the linker state defined by
	; the link file
	ldx numsegments
	bne @initsegments

	; TODO:create a default CODE segment
	sec
	rts

@initsegments:
	dex
	txa
	asl
	tay
@l0:	lda segments_startlo
	sta @segptrs,y
	lda segments_starthi
	sta @segptrs+1,y
	dex
	dey
	dey
	bpl @l0

	; init secptrs to the start addresses of each section
	ldx numsections
	bne @initsections
	RETURN_ERR ERR_NO_SECTIONS

@initsections:
	dex
	txa
	asl
	tay
@l1:	lda sections_startlo
	sta @secptrs,y
	lda sections_starthi
	sta @secptrs+1,y
	dex
	dey
	dey
	bpl @l1

	; load each .obj file


	; extract header data foreach file and update pointers to each file
	; to the main block of the .obj file
	jsr extract_headers

	; now that we have the sizes of each SEGMENT, build the start
	; addresses of each segment and update SECTION start pointer by the
	; SIZE of the SEGMENT we've assigned to that SECTION.
	ldx #$00
	ldy segments_load,x
	lda sections_startlo,y	; LSB of current SECTION start address
	sta segments_startlo,x	; store as SEGMENT's start address
	adc segments_sizelo,x
	sta sections_startlo,y	; update SECTION's new start address by SIZE
	lda sections_starthi,y
	sta segments_starthi,x
	adc segments_sizehi,x
	sta sections_starthi,y

	; make sure START is still less than STOP for the SECTION
	lda sections_starthi,y
	cmp sections_stophi,y
	bcc @objects
	bne @err			; if STARTHI > STOPHI, return err
	lda sections_startlo,y
	cmp sections_stoplo,y
	bcc @objects			; if ok, link the objects
@err:	RETURN_ERR ERR_SECTION_TOO_SMALL

; iterate over each object file and link them
@objects:
	lda #$00
	jsr link_object		; link the object
	bcs @done		; if .C set, return with error
	inc activeobj		; next object
	lda activeobj
	cmp numobjects
	bne @objects
	clc			; success
@done:	rts
.endproc

;*******************************************************************************
; LINK OBJECT
; Handles the main block of the object code defintion using the data extracted
; from the OBJ headers.
.proc link_object
	ldx activeobj
	; TODO: set IMPORTs for this OBJ file

@l0:	ldy #$00
	lda (objptr),y	; get an "instruction" from the OBJ code
	incw objptr	; move past "opcode"
	clc
	beq @done

	cmp #OBJ_BYTES		; bytes
	bne :+
	jsr obj_bytes
	jmp @l0

:	cmp #OBJ_RELWORD	; relative word?
	bne :+
	jsr obj_rel_word
	jmp @l0

:	cmp #OBJ_SETSEG		; set segment?
	bne @done		; unrecognized "opcode"
	jsr set_seg
	bcc @l0			; if no, error continue loop

@done:	rts
.endproc

;*******************************************************************************
; OBJ_BYTES
; Handles the OBJ_BYTES command
; Assembles the bytes that follow to the address of the current segment pointer,
; which is updated upon doing so
.proc obj_bytes
@ptr=r0
@cnt=r2
	ldy #$00
	lda (objptr),y ; read the number of bytes to output
	sta @cnt

	incw objptr
	lda (objptr),y ; read the number of bytes to output (hi)
	sta @cnt+1

	incw objptr

@l0:	lda (objptr),y	; get the byte to write to the binary
	sta (segptr),y	; output the byte from the object file
	incw segptr
	incw objptr
	decw @cnt
	bne @l0

	rts
.endproc

;******************************************************************************
; OBJ_REL_WORD
; Handles the OBJ_REL_WORD command
; Inserts a WORD with the value of the symobl that follows + an offset to
; the current address of the segment pointer
; A textual representation of this command looks like this:
;  `RW LABEL 12`
; LABEL is defined in the IMPORT section for the object code, so its binary
; representation refers to the offset in the IMPORT table
; The binary representation of the above command looks like this:
;  ` $02 $0030 $0c`
.proc obj_rel_word
@tmp=r0
	ldy #$00
	lda (objptr),y
	sta @tmp
	incw objptr
	lda (objptr),y
	sta @tmp+1
	incw objptr

	; add the offset
	lda (objptr),y
	clc
	adc @tmp
	sta (segptr),y
	iny
	lda (objptr),y
	adc @tmp+1
	sta (segptr),y

	; update object code and segment pointers
	incw objptr
	incw segptr
	incw objptr
	incw segptr
	rts
.endproc

;******************************************************************************
; SET SEG
; Sets the segment to the given segment name
; e.g.
;  SEG "DATA"
; The binary representatino is similar
;  $03 "DATA",0
; Where $03 is the binary opcode for "SEG" and "DATA" is still the literal
; segment data (0-terminated)
; IN:
;  - objptr: the current pointer in the object code
.proc set_seg
	; store the current end address of the active segment
	ldx activeseg
	lda segptr
	sta segments_stoplo,x
	lda segptr+1
	sta segments_stophi,x

	ldxy objptr
	jsr get_segment_by_name
	bcs @done		; return error if not found
	sta activeseg
	tax
	lda segments_stoplo,x
	sta segptr
	lda segments_stophi,x
	sta segptr+1

	; move past the name
	ldy #$ff
:	iny
	lda (objptr),y
	bne :-

	tya
	sec			; +1 (get past the 0)
	adc objptr
	bcc @done
	inc objptr+1
@done:	rts
.endproc

;*******************************************************************************
; EXTRACT HEADERS
; Extracts the header data from the .obj file and builds the absolute address
; of any EXPORTs for the .obj file. These are added as labels (lbl::add).
; Then updates the SEGMENT pointers by the sizes of each SEGMENT used in the
; .obj file.
;
; The first block contains the names of all segments used in the object file.
; This is a list of 0-terminated strings.
; ---------------------------------
; |  Property       | Size (bytes)|
; |-----------------|-------------|
; | Segment 1 Name  |  1-32       |
; | Segment 2 Name  |  1-32       |
; | end marker (0)  |  1          |
; ---------------------------------
;
; The next block contains the EXPORTs for the block.
; The EXPORT block contains the names of all symbols exported by the object
; file as well as their relative segment offsets
;
; Segments are identified by a 1 byte ID, which refers to their index in
; the segment table for the object file
;
; -----------------------------------------
; |  Property               | Size (bytes)|
; |-------------------------|-------------|
; | Export 1 Name           |  1-32       |
; | Export 1 Segment        |    1        |
; | Export 1 Segment Offset |    1        |
; | Export 2 Name           |  1-32       |
; | Export 2 Segment        |    1        |
; | Export 2 Segment Offset |    1        |
; -----------------------------------------
;
; The second block contains the IMPORTs for the block
; This is a list of 0-terminated strings
; --------------------------------
; |  Property      | Size (bytes)|
; |----------------|-------------|
; | Import 1 Name  |  1-32       |
; | Import 2 Name  |  1-32       |
; | end marker (0) |  1          |
; --------------------------------
;
; The 3rd block of headers tells the linker the name and size of each SEGMENT
; in the .obj file
; --------------------------------
; |  Property      | Size (bytes)|
; |----------------|-------------|
; | SEG1 name      |  16         |
; | sizeof(SEG1)   |  2          |
; | SEG2 name      |  16         |
; | sizeof(SEG2)   |  2          |
; | end marker (0) |  1          |
; --------------------------------
;
; IN:
;  - .XY: address to the contents of the .obj file
; OUT:
;  - .XY:             address of the remainder of the .obj file (after headers)
;  - segments_stoplo: updated with new LSBs of end of affected segments
;  - segments_stophi: updated with new MSBs of end of affected segments
;  - labels:          updated with any EXPORTed symbols from .obj file
.proc extract_headers
EXPORT_SEG  = 8 		; offset to SEGMENT name in IMPORT header
EXPORT_SIZE = 8+8		; offset to SIZE in IMPORT header
EXPORT_BLOCK_ITEM_SIZE = 8 + EXPORT_SEG + EXPORT_SIZE
@fptr=r0
@segaddr=r2
@buff=r4
	stxy @fptr
	ldx numfiles
@getsegments:

@getexports:
	; get the absolute address of the segment
	lda #EXPORT_SEG
	clc
	adc @buff
	tax
	lda @buff+1
	adc #$00
	tay
	jsr get_segment_by_name
	stxy @segaddr

	; calclulate the absolute address for the EXPORT
	ldy #EXPORT_SIZE
	lda (@buff),y
	clc
	adc @segaddr
	sta zp::label_value
	iny
	lda (@buff),y
	adc @segaddr+1
	sta zp::label_value+1

	ldxy #@buff	; name of the EXPORT
	jsr lbl::add	; add the EXPORT to the symbol table

	; move fptr to next EXPORT or block
	lda @fptr
	clc
	adc #EXPORT_BLOCK_ITEM_SIZE
	sta @fptr
	bcc :+
	inc @fptr
:	ldy #$00
	lda (@fptr),y
	bne @getexports ; if not end of block, continue
	incw @fptr	; move past terminating 0

; TODO: deal with IMPORT block

; sum the SEGMENT sizes for the header with our existing sizes for those
; segments and set the STOP addresses accordingly
@updatesegments:
	ldxy #@fptr		; SEGMENT name
	jsr get_segment_by_name
	tax
	ldy #8			; offset to SIZE
	lda (@fptr),y
	clc
	adc segments_sizelo,x
	sta segments_sizelo,x
	iny
	lda (@fptr),y
	adc segments_sizehi,x
	sta segments_sizehi,x

	lda @fptr
	adc #10			; sizeof(NAME) + sizeof(SIZE)
	sta @fptr
	bcc :+
	inc @fptr+1
:	ldy #$00
	lda (@fptr),y
	bne @updatesegments	; loop if not end of SEGMENT block

	incw @fptr
	ldxy @fptr
	rts
.endproc

;******************************************************************************
; GET SEGMENT BY NAME
; Returns the ID of the segment from its name
; IN:
;  - .XY: the name of the segment
; OUT:
;  - .A: the ID of the segment
;  - .C: set if no segment exists by the given name
.proc get_segment_by_name
@name=zp::str0
@other=zp::str2
@cnt=r0
	stxy @name
	ldxy #segment_names
	stxy @other

	lda #$00
	sta @cnt
@l0:	lda #$08
	jsr strcmp
	beq @found
	lda @other
	clc
	adc #$08
	sta @other
	ldx @cnt
	inx
	stx @cnt
	cpx numsegments
	bcc @l0
@notfound:
	rts

@found: lda @cnt
	RETURN_OK
.endproc

;*******************************************************************************
; PARSE KV
; Parses a key/value pair
; e.g. A=120
; The left hand side is read as a string into the given buffer and the right
; is read a number and returned
; A maximum of 8 characters are read for the key
; IN:
;   - zp::line: points to the buffer to parse the pair from
;   - .XY:      buffer to store the key to
; OUT:
;   - .XY:      the value of the key/value pair
;   - .C:       set if the key/value pair was not parsed successfully
.proc parse_kv
@buff=r0
	stxy @buff
	jsr process_ws
	; read the key into the buffer
	ldy #$00
:	lda (zp::line),y
	beq @err
	cmp #' '
	beq @geteq
	cmp #'='
	beq @getvalue
	sta (@buff),y
	iny
	cpy #$08
	bne :-
	; sec
	rts

@geteq:
	jsr process_ws
	lda (zp::line),y
	cmp #'='
	bne @err		; separator between key and value must be '='

@getvalue:
	jsr process_ws
	incw zp::line		; move beyond the '='

	; get the value for the key, value pair
	CALL FINAL_BANK_MAIN, #util::parsehex
	rts

@err:	sec
	rts
.endproc

;*******************************************************************************
; COMPARE LINE
; Compares the strings in (zp::line) and (.XY) up to a length of .A
.proc cmpline
	stxy zp::str2
	ldxy zp::line
	stxy zp::str0

	; fall through to strcmp
.endproc

;*******************************************************************************
; COMPARE
; Compares the strings in (zp::str0) and (zp::str2) up to a length of .A
; IN:
;  zp::line: one of the strings to compare
;  .XY:      the other string to compare
;  .A:       the max length to compare
; OUT:
;  .Z: set if the strings are equal
.proc strcmp
	tay		; is length to compare 0?
	dey
	bmi @match	; if 0-length comparison, it's a match by default

@l0:	lda (zp::line),y
	cmp (zp::str0),y
	bne @ret
	dey
	bpl @l0
@match:	lda #$00
@ret:	rts
.endproc

;*******************************************************************************
; PROCESS_WS
; Reads (line) and updates it to point past ' ' chars and non-printing chars
; out:
;  .Z: set if we're at the end of the line
;  .A: the last character processed
;  .Y: 0
;  zp::line: updated to first non ' ' character
.proc process_ws
	ldy #$00
@l0:	lda (zp::line),y
	beq :+			; if end of line, we're done
	bmi @skip		; skip non-printing chars
	jsr util::is_whitespace
	bne :+			; if not space, we're done
@skip:	jsr __line_inc
	bne @l0
:	rts
.endproc
